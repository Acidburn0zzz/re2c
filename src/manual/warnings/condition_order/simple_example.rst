A simple example
~~~~~~~~~~~~~~~~

The following lexer consists of two conditions: ``a`` and ``b``.
It starts in condition ``a``, which expects a sequence of letters ``'a'`` followed by a comma.
The comma causes transition to condition ``b``, which expects a sequence of letters ``'b'`` followed by an exclamation mark.
Anything else is an error.
Nothing special, except that instead of generating condition names with the ``/*!types:re2c*/`` directive
or the ``-t, --type-header`` option, we've hardcoded them manually:

:download:`[wcondition_order.re] <wcondition_order.re.txt>`

.. literalinclude:: wcondition_order.re.txt
    :language: cpp
    :linenos:

Condition order is controlled by the ``REVERSED_CONDITION_ORDER`` define.
Let's compile and run it:

.. code-block:: none

    $ re2c -c -o example.c -Wcondition-order wcondition_order.re
    $
    $ g++ -o example example.c
    $ ./example
    aaaa,bbb!
    $
    $ g++ -o example -DREVERSED_CONDITION_ORDER example.c
    $ ./example
    aaaa,bbb!

Everything works fine: we get ``aaaa,bbb!`` in both cases.
However, if we use the ``-s`` re2c option, the lexer becomes sensitive to condition order:

.. code-block:: none

    $ re2c -cs -o example.c -Wcondition-order wcondition_order.re
    re2c: warning: line 31: looks like you use hardcoded numbers instead of autogenerated condition names: better add
    '/*!types:re2c*/' directive or '-t, --type-header' option and don't rely on fixed condition order. [-Wcondition-order]
    $
    $ g++ -o example example.c
    $ ./example
    aaaa,bbb!
    $
    $ g++ -o example -DREVERSED_CONDITION_ORDER example.c
    $ ./example
    error

And we also get a warning from re2c.
The same behavior (re2c warning and error with ``-DREVERSED_CONDITION_ORDER``) remains if we use the ``-g`` option
(or any option that implies ``-s`` or ``-g``).
Why is that?
A look at the generated code explains everything.
Normally the initial dispatch on conditions is a ``switch`` statement:

.. code-block:: cpp

	switch (c) {
	case yyca: goto yyc_a;
	case yycb: goto yyc_b;
	}

Dispatch uses explicit condition names and works no matter what numbers are assigned to them.
However, with the ``-s`` option, re2c generates an ``if`` statement instead of a ``switch``:

.. code-block:: cpp

	if (c < 1) {
		goto yyc_a;
	} else {
		goto yyc_b;
	}

And with the ``-g`` option, it uses a jump table (computed ``goto``):

.. code-block:: cpp

	static void *yyctable[2] = {
		&&yyc_a,
		&&yyc_b,
	};
	goto *yyctable[c];

Clearly, the last two cases are condition order sensitive .
The fix is easy: as the warning suggests, use the ``/*!types:re2c*/`` directive or the ``-t, --type-header`` option.

