A simple example
~~~~~~~~~~~~~~~~

The following lexer consists of two conditions: ``a`` and ``b``.
It starts in condition ``a``, which expects a sequence of letters ``'a'`` followed by a comma.
Comma causes transition to condition ``b``, which expects a sequence of letters ``'b'`` followed by an exclamation.
Anything else is an error.
Nothing special, except that instead of generating condition names with ``/*!types:re2c*/`` directive
or ``-t, --type-header`` option we hardcoded them manually:

`[wcondition_order.re] <wcondition_order.re>`_

.. include:: wcondition_order.re
    :code: cpp
    :number-lines:

Condition order is controlled by ``REVERSED_CONDITION_ORDER`` define.
Let's compile and run it:

.. code-block::

    $ re2c -c -o example.c -Wcondition-order wcondition_order.re
    $
    $ g++ -o example example.c
    $ ./example
    aaaa,bbb!
    $
    $ g++ -o example -DREVERSED_CONDITION_ORDER example.c
    $ ./example
    aaaa,bbb!

Everything works fine: we get ``aaaa,bbb!`` in both cases.
However, if we use ``-s`` re2c option, lexer becomes sensitive to condition order:

.. code-block::

    $ re2c -cs -o example.c -Wcondition-order wcondition_order.re
    re2c: warning: line 31: looks like you use hardcoded numbers instead of autogenerated condition names: better add
    '/*!types:re2c*/' directive or '-t, --type-header' option and don't rely on fixed condition order. [-Wcondition-order]
    $
    $ g++ -o example example.c
    $ ./example
    aaaa,bbb!
    $
    $ g++ -o example -DREVERSED_CONDITION_ORDER example.c
    $ ./example
    error

And we also get a warning from re2c.
The same behaviour (re2c warning and error with ``-DREVERSED_CONDITION_ORDER``) remains if we use ``-g`` option
(or any option that implies ``-s`` or ``-g``).
Why is that?
A look at the generated code explains everything.
Normally the inital dispatch on conditions is a ``switch`` statement:

.. code-block:: cpp

	switch (c) {
	case yyca: goto yyc_a;
	case yycb: goto yyc_b;
	}

Dispatch uses explicit condition names and works no matter what numbers are assigned to them.
However, with ``-s`` option re2c generates an ``if`` statement instead of a ``switch``:

.. code-block:: cpp

	if (c < 1) {
		goto yyc_a;
	} else {
		goto yyc_b;
	}

And with ``-g`` option it uses jump table (computed ``goto``):

.. code-block:: cpp

	static void *yyctable[2] = {
		&&yyc_a,
		&&yyc_b,
	};
	goto *yyctable[c];

Clearly, the last two cases are sensitive to condition order.
The fix is easy: as the warning suggests, use ``/*!types:re2c*/`` directive or ``-t, --type-header`` option.

