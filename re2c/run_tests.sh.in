#!/bin/bash

# somewhat portable way to detect CPU count
detect_cpu_count () {
    if [ "$CPUS" = "" ]; then
        # Windows standard environment variable
        CPUS="$NUMBER_OF_PROCESSORS"
    fi
    if [ "$CPUS" = "" ]; then
        # Linux
        CPUS=`getconf _NPROCESSORS_ONLN 2>/dev/null`
    fi
    if [ "$CPUS" = "" ]; then
        # FreeBSD
        CPUS=`getconf NPROCESSORS_ONLN 2>/dev/null`
    fi
    if [ "$CPUS" = "" ]; then
        # nothing helped
        CPUS="1"
    fi
}

valgrind=""
skeleton=0
keep_tmp_files=0
wine=""
re2c="./re2c"
threads=`detect_cpu_count; echo $CPUS`
tests=()
for arg in $*
do
	case $arg in
		"--valgrind" ) valgrind=`which valgrind` ;;
		"--skeleton" ) skeleton=1 ;;
		"--keep-tmp-files" ) keep_tmp_files=1 ;;
		"--wine" )
			wine=`which wine`
			re2c="${re2c}.exe"
			;;
		"-j"* )
			number=${arg#-j}
			number_pattern='^[0-9]+$'
			if [[ $number =~ $number_pattern ]]
			then
				threads=$number
			fi
			;;
		* ) tests+=("$arg") ;;
	esac
done
echo "Running in ${threads} thread(s)"

test_srcdir=""
if [ ${#tests[@]} -eq 0 ]
then
    test_srcdir="@top_srcdir@/test"
    tests=(`find $test_srcdir -name '*.re' | sort`)
fi
test_blddir="test_"`date +%y%m%d%H%M%S`
rm -rf $test_blddir && mkdir $test_blddir

tests_per_thread=$((${#tests[@]} / threads + 1))
packs=()
for ((i = 0; i < threads; i++))
do
	j=$((i * tests_per_thread))
	packs[$i]=${tests[@]:j:tests_per_thread}
done

if test ! -x "${re2c}"
then
	echo "Cannot find re2c executable (${re2c})."
	exit 1
fi

if test -n "${valgrind}"
then
	valgrind_options=(
		"-q"
		"--track-origins=yes"
		"--num-callers=50"
		"--leak-check=full"
		"--show-reachable=yes"
		"--malloc-fill=0xa1"
		"--free-fill=0xa1"
		)
	valgrind="${valgrind} ${valgrind_options[@]}"
	echo $valgrind
fi

diff_prog="diff"
if test -n "${wine}"
then
	# ignore whitespace at the end of line
	diff_prog="${diff_prog} -b"
fi

run_pack() {
	local log="$1"
	shift 1

	local errcnt=0
	for x in $*
	do
		# preserve directory structure unless given explicit args
		if [ -z "$test_srcdir" ]
		then
			local outx=$test_blddir/`basename $x`
		else
			local outx=${test_blddir}${x:${#test_srcdir}}
			mkdir -p `dirname $outx`
		fi
		local outname=${outx%.re}.c.temp
		local outdiff=${outx%.re}.c.diff
		local outc="${outx%.re}.c"

		local switches=`basename $x | sed -e 's/^[^.]*\.\(.*\)\.re$/-\1/g' -e 's/^[^-].*//g' -e 's/\([^ ]\)--/\1 --/g' -e 's/(\([^)]*\))/ \1/g' -e 's/- //g'`
		local outh=` printf "%s" "$switches" | grep -e '^-[^t -]*t[^ -]\+' | sed -e 's,^-[^t -]*t\([^ -]\+\),'"$test_blddir"'/\1,g'`
		local switches=`printf "%s" "$switches" | sed -e 's,^-\([^ot-]*[ot]\)\(.*\)$,-\1'"$test_blddir"'/\2,g'`
		local switches="$switches -o $outc"
		# enable warnings globally
		local switches="$switches -W"

		local cmd="${valgrind} ${wine} ${re2c} $switches $x"

		if [ $skeleton -eq 1 ]
		then
			cmd="${cmd} --skeleton -Werror-undefined-control-flow"
			mkdir -p `dirname "$outc"`

			local status=""
			[ -z $status ] && status=`$cmd 2>"$outc".stderr || echo "FAIL_RE2C"`
			[ -z $status ] && status=`gcc -Wall -Wextra -o "$outc".out "$outc" 2>>"$outc".stderr || echo "FAIL_CC"`
			[ -z $status ] && status=`./"$outc".out 2>>"$outc".stderr || echo "FAIL_RUN"`
			[ -z $status ] && status="OK"
			if [ $status = "OK" -o $status = "FAIL_RE2C" ]
			then
				[ $keep_tmp_files -eq 0 ] && rm -f "$outc"{,.line*.{input,keys},.stderr,.out}
			else
				cp -f $x $outx
				local errcnt=$(($errcnt + 1))
			fi

			echo "$status $x"
		else
			local outname_stderr="${outname}.stderr"
			$cmd 2>$outname_stderr
			cat $outname_stderr $outc > $outname
			rm $outname_stderr $outc
			# don't forget '-S, --skeleton' files
			for f in `find $(dirname $outc) -type f -name "$(basename $outc).line*.input"`
			do
				cat $f ${f%.input}.keys >> $outname
				rm $f ${f%.input}.keys
			done
			# don't forget '-t, --type-header' files
			[ -n "$outh" ] && cat "$outh" >> $outname && rm "$outh"

			LC_ALL=C sed -i $outname \
				-e "s,$x,`basename $x`,g" \
				-e "s,$outc,<stdout>,g" \
				-e "s,$outh,`[ -z $outh ] || basename $outh`,g" \
				-e 's,/\* Generated by re2c .*\*/,/\* Generated by re2c \*/,g'

			if test ! -f ${x%.re}.c
			then
				echo "FAIL missing ${x%.re}.c"
				local errcnt=$(($errcnt + 1))
				cp -f $x $outx
			else
				local r=`$diff_prog ${x%.re}.c $outname > $outdiff; echo $?`
				if [[ $r == 0 ]]
				then
					echo "OK $x: $switches"
					rm $outname
				else
					echo "FAIL $x: $switches"
					local errcnt=$(($errcnt + 1))
					cp -f $x $outx
					cp -f ${x%.re}.c ${outx%.re}.c
				fi
			fi
			test -f $outdiff -a ! -s $outdiff && rm -f $outdiff
		fi
	done
	echo $errcnt > $log
}

cleanup() {
	rm -f ${logs[@]}
	kill ${wait_pids[@]}
	wait ${wait_pids[@]}
	printf "\nEh...\n"
	exit 1
}

logs=()
wait_pids=()
trap cleanup INT
for ((i = 0; i < ${#packs[@]}; i++))
do
	logs[$i]=`date +%y%m%d%H%M%S`_$i
	run_pack ${logs[i]} ${packs[i]} &
	wait_pids+=( $! )
done
wait ${wait_pids[@]}

errors=0
for ((i = 0; i < ${#logs[@]}; i++))
do
	error=`cat ${logs[i]}`
	errors=$((errors + error))
	rm -f ${logs[i]}
done

# remove empty directories
for d in `find $test_blddir -depth -type d`
do
	entries=`ls -A "$d"`
	if [ -z "$entries" ]
	then
		rmdir "$d"
	fi
done

if [ $errors -eq 0 ]
then
	echo "All ${#tests[@]} tests passed successfully."
	exit 0
else
	echo "Error: $errors out ${#tests[@]} tests failed."
	exit 1
fi
