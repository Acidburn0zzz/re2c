<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.12: http://docutils.sourceforge.net/" />
<title>A simple example</title>
<link rel="stylesheet" type="text/css" href="/css/default.css" />
<link rel="alternate" type="application/atom+xml" href="/feed/atom.xml" title="Atom 1.0" />
<link rel="icon" href="/favicon.ico" />
</head>
<body>
<div class="document" id="a-simple-example">
<h1 class="title">A simple example</h1>

<p>The following lexer consists of two conditions: <tt class="docutils literal">a</tt> and <tt class="docutils literal">b</tt>.
It starts in condition <tt class="docutils literal">a</tt>, which expects a sequence of letters <tt class="docutils literal">'a'</tt> followed by a comma.
Comma causes transition to condition <tt class="docutils literal">b</tt>, which expects a sequence of letters <tt class="docutils literal">'b'</tt> followed by an exclamation.
Anything else is an error.
Nothing special, except that instead of generating condition names with <tt class="docutils literal"><span class="pre">/*!types:re2c*/</span></tt> directive
or <tt class="docutils literal"><span class="pre">-t,</span> <span class="pre">--type-header</span></tt> option we hardcoded them manually:</p>
<p><a class="reference external" href="wcondition_order.re">[wcondition_order.re]</a></p>
<pre class="code cpp literal-block">
<span class="ln"> 1 </span><span class="comment preproc">#include &lt;stdio.h&gt;
</span><span class="ln"> 2 </span><span class="comment preproc"></span>
<span class="ln"> 3 </span><span class="comment preproc">#ifdef REVERSED_CONDITION_ORDER
</span><span class="ln"> 4 </span><span class="comment preproc">#    define yyca 1
</span><span class="ln"> 5 </span><span class="comment preproc">#    define yycb 0
</span><span class="ln"> 6 </span><span class="comment preproc">#else
</span><span class="ln"> 7 </span><span class="comment preproc">#    define yyca 0
</span><span class="ln"> 8 </span><span class="comment preproc">#    define yycb 1
</span><span class="ln"> 9 </span><span class="comment preproc">#endif
</span><span class="ln">10 </span><span class="comment preproc"></span>
<span class="ln">11 </span><span class="keyword type">int</span> <span class="name function">main</span><span class="punctuation">()</span>
<span class="ln">12 </span><span class="punctuation">{</span>
<span class="ln">13 </span>    <span class="keyword">const</span> <span class="keyword type">char</span> <span class="operator">*</span> <span class="name">YYCURSOR</span> <span class="operator">=</span> <span class="literal string">&quot;aaaa,bbb!&quot;</span><span class="punctuation">;</span>
<span class="ln">14 </span>    <span class="keyword type">int</span> <span class="name">c</span> <span class="operator">=</span> <span class="name">yyca</span><span class="punctuation">;</span>
<span class="ln">15 </span>    <span class="keyword">for</span> <span class="punctuation">(;;)</span> <span class="punctuation">{</span>
<span class="ln">16 </span>    <span class="comment multiline">/*!re2c
</span><span class="ln">17 </span><span class="comment multiline">        re2c:define:YYCTYPE = char;
</span><span class="ln">18 </span><span class="comment multiline">        re2c:yyfill:enable = 0;
</span><span class="ln">19 </span><span class="comment multiline">        re2c:define:YYSETCONDITION = &quot;c = &#64;&#64;;&quot;;
</span><span class="ln">20 </span><span class="comment multiline">        re2c:define:YYSETCONDITION:naked = 1;
</span><span class="ln">21 </span><span class="comment multiline">        re2c:define:YYGETCONDITION = c;
</span><span class="ln">22 </span><span class="comment multiline">        re2c:define:YYGETCONDITION:naked = 1;
</span><span class="ln">23 </span><span class="comment multiline">
</span><span class="ln">24 </span><span class="comment multiline">        &lt;*&gt; * { printf (&quot;error\n&quot;); break; }
</span><span class="ln">25 </span><span class="comment multiline">
</span><span class="ln">26 </span><span class="comment multiline">        &lt;a&gt; &quot;a&quot;      { printf (&quot;a&quot;); continue; }
</span><span class="ln">27 </span><span class="comment multiline">        &lt;a&gt; &quot;,&quot; =&gt; b { printf (&quot;,&quot;); continue; }
</span><span class="ln">28 </span><span class="comment multiline">
</span><span class="ln">29 </span><span class="comment multiline">        &lt;b&gt; &quot;!&quot; { printf (&quot;!\n&quot;); break; }
</span><span class="ln">30 </span><span class="comment multiline">        &lt;b&gt; &quot;b&quot; { printf (&quot;b&quot;); continue; }
</span><span class="ln">31 </span><span class="comment multiline">    */</span>
<span class="ln">32 </span>    <span class="punctuation">}</span>
<span class="ln">33 </span>    <span class="keyword">return</span> <span class="literal number integer">0</span><span class="punctuation">;</span>
<span class="ln">34 </span><span class="punctuation">}</span>
</pre>
<p>Condition order is controlled by <tt class="docutils literal">REVERSED_CONDITION_ORDER</tt> define.
Let's compile and run it:</p>
<pre class="code literal-block">
$ re2c -c -o example.c -Wcondition-order wcondition_order.re
$
$ g++ -o example example.c
$ ./example
aaaa,bbb!
$
$ g++ -o example -DREVERSED_CONDITION_ORDER example.c
$ ./example
aaaa,bbb!
</pre>
<p>Everything works fine: we get <tt class="docutils literal">aaaa,bbb!</tt> in both cases.
However, if we use <tt class="docutils literal"><span class="pre">-s</span></tt> re2c option, lexer becomes sensitive to condition order:</p>
<pre class="code literal-block">
$ re2c -cs -o example.c -Wcondition-order wcondition_order.re
re2c: warning: line 31: looks like you use hardcoded numbers instead of autogenerated condition names: better add
'/*!types:re2c*/' directive or '-t, --type-header' option and don't rely on fixed condition order. [-Wcondition-order]
$
$ g++ -o example example.c
$ ./example
aaaa,bbb!
$
$ g++ -o example -DREVERSED_CONDITION_ORDER example.c
$ ./example
error
</pre>
<p>And we also get a warning from re2c.
The same behaviour (re2c warning and error with <tt class="docutils literal"><span class="pre">-DREVERSED_CONDITION_ORDER</span></tt>) remains if we use <tt class="docutils literal"><span class="pre">-g</span></tt> option
(or any option that implies <tt class="docutils literal"><span class="pre">-s</span></tt> or <tt class="docutils literal"><span class="pre">-g</span></tt>).
Why is that?
A look at the generated code explains everything.
Normally the inital dispatch on conditions is a <tt class="docutils literal">switch</tt> statement:</p>
<pre class="code cpp literal-block">
<span class="keyword">switch</span> <span class="punctuation">(</span><span class="name">c</span><span class="punctuation">)</span> <span class="punctuation">{</span>
<span class="keyword">case</span> <span class="name label">yyca</span><span class="punctuation">:</span> <span class="keyword">goto</span> <span class="name">yyc_a</span><span class="punctuation">;</span>
<span class="keyword">case</span> <span class="name label">yycb</span><span class="punctuation">:</span> <span class="keyword">goto</span> <span class="name">yyc_b</span><span class="punctuation">;</span>
<span class="punctuation">}</span>
</pre>
<p>Dispatch uses explicit condition names and works no matter what numbers are assigned to them.
However, with <tt class="docutils literal"><span class="pre">-s</span></tt> option re2c generates an <tt class="docutils literal">if</tt> statement instead of a <tt class="docutils literal">switch</tt>:</p>
<pre class="code cpp literal-block">
<span class="keyword">if</span> <span class="punctuation">(</span><span class="name">c</span> <span class="operator">&lt;</span> <span class="literal number integer">1</span><span class="punctuation">)</span> <span class="punctuation">{</span>
        <span class="keyword">goto</span> <span class="name">yyc_a</span><span class="punctuation">;</span>
<span class="punctuation">}</span> <span class="keyword">else</span> <span class="punctuation">{</span>
        <span class="keyword">goto</span> <span class="name">yyc_b</span><span class="punctuation">;</span>
<span class="punctuation">}</span>
</pre>
<p>And with <tt class="docutils literal"><span class="pre">-g</span></tt> option it uses jump table (computed <tt class="docutils literal">goto</tt>):</p>
<pre class="code cpp literal-block">
<span class="keyword">static</span> <span class="keyword type">void</span> <span class="operator">*</span><span class="name">yyctable</span><span class="punctuation">[</span><span class="literal number integer">2</span><span class="punctuation">]</span> <span class="operator">=</span> <span class="punctuation">{</span>
        <span class="operator">&amp;&amp;</span><span class="name">yyc_a</span><span class="punctuation">,</span>
        <span class="operator">&amp;&amp;</span><span class="name">yyc_b</span><span class="punctuation">,</span>
<span class="punctuation">};</span>
<span class="keyword">goto</span> <span class="operator">*</span><span class="name">yyctable</span><span class="punctuation">[</span><span class="name">c</span><span class="punctuation">];</span>
</pre>
<p>Clearly, the last two cases are sensitive to condition order.
The fix is easy: as the warning suggests, use <tt class="docutils literal"><span class="pre">/*!types:re2c*/</span></tt> directive or <tt class="docutils literal"><span class="pre">-t,</span> <span class="pre">--type-header</span></tt> option.</p>
</div>
</body>
</html>
