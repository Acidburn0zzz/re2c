
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Strings &#8212; re2c 1.0.1 documentation</title>
    <link rel="stylesheet" href="../_static/theme-re2c.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="alternate" type="application/atom+xml" href="../feed/atom.xml" title="Atom 1.0" />
    
 
  </head>
  <body>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="re2c-logo">
    re2c-1.0.1
</div>

<h3><a href="../index.html">Home</a></h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../about/about.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install/install.html">Install</a></li>
<li class="toctree-l1"><a class="reference internal" href="../manual/manual.html">Manual</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="examples.html">Examples</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="example_01.html">Numbers</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Strings</a></li>
<li class="toctree-l2"><a class="reference internal" href="example_03.html">Large input</a></li>
<li class="toctree-l2"><a class="reference internal" href="example_04.html">Multiple blocks</a></li>
<li class="toctree-l2"><a class="reference internal" href="example_05.html">Conditions</a></li>
<li class="toctree-l2"><a class="reference internal" href="example_12.html">Floating-point</a></li>
<li class="toctree-l2"><a class="reference internal" href="example_08.html">IPv4 address</a></li>
<li class="toctree-l2"><a class="reference internal" href="example_09.html">/etc/passwd</a></li>
<li class="toctree-l2"><a class="reference internal" href="example_14.html">Options &amp; arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="example_13.html">Records &amp; structs</a></li>
<li class="toctree-l2"><a class="reference internal" href="example_07.html">C++98</a></li>
<li class="toctree-l2"><a class="reference internal" href="example_10.html">URI (RFC-3986)</a></li>
<li class="toctree-l2"><a class="reference internal" href="example_11.html">HTTP (RFC-7230)</a></li>
<li class="toctree-l2"><a class="reference internal" href="example_06.html">Braille patterns</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../news/news.html">News</a></li>
</ul>


        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="strings">
<h1>Strings<a class="headerlink" href="#strings" title="Permalink to this headline">¶</a></h1>
<p>This example is about recognizing strings.
Strings (in the generic sense) are different from other kinds of lexemes: they can contain <em>arbitrary</em> characters.
That makes them way more difficult to lex: unlike in the <a class="reference external" href="example_01.html">Numbers</a> example,
we cannot use a sentinel character to stop at the end of input.
Suppose, for example, that our strings may be single or double-quoted
and may contain any character in range <code class="docutils literal"><span class="pre">[0</span> <span class="pre">-</span> <span class="pre">0xFF]</span></code> except quotes of the appropriate type.
This time we cannot use <code class="docutils literal"><span class="pre">\0</span></code> as a sentinel: input strings such as <code class="docutils literal"><span class="pre">&quot;aha\0ha&quot;</span></code> are perfectly valid,
but ill-formed strings such as <code class="docutils literal"><span class="pre">&quot;aha\0</span></code> are also possible and shouldn’t crash the lexer.
Any other character cannot be used for the same reason
(including quotes: each type of string may contain quotes of the opposite type).</p>
<p>By default, re2c-generated lexers use the following approach to check for the end of the input buffer:
they assume that <code class="docutils literal"><span class="pre">YYLIMIT</span></code> is a pointer to the end of the input buffer, and they check by simply comparing <code class="docutils literal"><span class="pre">YYCURSOR</span></code> and <code class="docutils literal"><span class="pre">YYLIMIT</span></code>.
The obvious way to accomplish this is by checking on each input character (before advancing to the next character), but that’s very slow.
Instead, re2c inserts checks only at certain points in the generated program.
Each check ensures that there is enough input to proceed until the next check.
If the check fails, the lexer calls <code class="docutils literal"><span class="pre">YYFILL(n)</span></code>, which may either supply at least <code class="docutils literal"><span class="pre">n</span></code> characters or stop:</p>
<blockquote>
<div><code class="docutils literal"><span class="pre">if</span> <span class="pre">((YYLIMIT</span> <span class="pre">-</span> <span class="pre">YYCURSOR)</span> <span class="pre">&lt;</span> <span class="pre">n)</span> <span class="pre">YYFILL(n);</span></code></div></blockquote>
<p>For those interested in the internal re2c algorithm used to determine checkpoints,
here is a quotation from the original paper
<a class="reference external" href="../1994_bumbulis_cowan_re2c_a_more_versatile_scanner_generator.pdf">“RE2C: a more versatile scanner generator”</a>
<em>by Peter Bumbulis, Donald D. Cowan, 1994, ACM Letters on Programming Languages and Systems (LOPLAS)</em>:</p>
<blockquote>
<div><em>A set of key states can be determined by discovering the strongly-connected components (SCCs) of the
DFA. An SCC is a maximal subset of states such that there exists a path from any state in the subset to any
other. The set of key states consists of all of the states in non-trivial SCCs, together with the start state.
Note that for each SCC S, we actually only have to include a subset of states of S such that when the subset
is removed, S becomes acyclic.</em></div></blockquote>
<p>This approach reduces the number of checks significantly, but it has a downside.
Since the lexer checks for multiple characters at once, the last few input characters may become unreachable.
A common hack is to pad the input with a few fake characters that <strong>do not form a valid lexeme or lexeme suffix</strong>.
The length of the padding depends on the maximum argument to <code class="docutils literal"><span class="pre">YYFILL</span></code>
(this value is called <code class="docutils literal"><span class="pre">YYMAXFILL</span></code> and can be generated with the <code class="docutils literal"><span class="pre">/*!max:re2c*/</span></code> directive).</p>
<p><a class="reference download internal" href="../_downloads/02_recognizing_strings.re.txt" download=""><code class="xref download docutils literal"><span class="pre">[strings.re]</span></code></a></p>
<div class="highlight-cpp"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>

<span class="cm">/*!max:re2c*/</span>

<span class="k">struct</span> <span class="n">input_t</span> <span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">;</span>

    <span class="n">input_t</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">len</span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
        <span class="p">,</span> <span class="n">str</span><span class="p">(</span><span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">len</span> <span class="o">+</span> <span class="n">YYMAXFILL</span><span class="p">])</span>
    <span class="p">{</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">str</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="n">YYMAXFILL</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="o">~</span><span class="n">input_t</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">delete</span><span class="p">[]</span><span class="n">str</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">bool</span> <span class="nf">lex</span><span class="p">(</span><span class="k">const</span> <span class="n">input_t</span> <span class="o">&amp;</span> <span class="n">input</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">YYCURSOR</span> <span class="o">=</span> <span class="n">input</span><span class="p">.</span><span class="n">str</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">YYLIMIT</span> <span class="o">=</span> <span class="n">input</span><span class="p">.</span><span class="n">str</span> <span class="o">+</span> <span class="n">input</span><span class="p">.</span><span class="n">len</span> <span class="o">+</span> <span class="n">YYMAXFILL</span><span class="p">;</span>
    <span class="cm">/*!re2c</span>
<span class="cm">        re2c:define:YYCTYPE = char;</span>
<span class="cm">        re2c:define:YYFILL = &quot;return false;&quot;;</span>
<span class="cm">        re2c:define:YYFILL:naked = 1;</span>

<span class="cm">        sstr = &quot;&#39;&quot;  [^&#39;]* &quot;&#39;&quot;;</span>
<span class="cm">        dstr = &quot;\&quot;&quot; [^&quot;]* &quot;\&quot;&quot;;</span>

<span class="cm">        *             { return false; }</span>
<span class="cm">        (sstr | dstr) { return YYLIMIT - YYCURSOR == YYMAXFILL; }</span>
<span class="cm">    */</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">argc</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">input_t</span> <span class="n">arg</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">lex</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;str&quot;</span> <span class="o">:</span> <span class="s">&quot;err&quot;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>Notes:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">/*!max:re2c*/</span></code> (line 4) tells re2c to generate <code class="docutils literal"><span class="pre">#define</span> <span class="pre">YYMAXFILL</span> <span class="pre">n</span></code>.</li>
<li>The input string is padded with <code class="docutils literal"><span class="pre">YYMAXFILL</span></code> <code class="docutils literal"><span class="pre">'a'</span></code> characters (line 15).
The sequence of <code class="docutils literal"><span class="pre">'a'</span></code> does not form a valid lexeme or lexeme suffix
(but padding with quotes would cause false matches on ill-formed inputs such as <code class="docutils literal"><span class="pre">&quot;aha</span></code>).</li>
<li><code class="docutils literal"><span class="pre">YYLIMIT</span></code> points at the end of the padding (line 26).</li>
<li><code class="docutils literal"><span class="pre">YYFILL</span></code> returns an error (line 29): if the input was correct, the lexer should have stopped
at the beginning of the padding.</li>
<li>If the rule matched (line 36), we ensure that the lexer has consumed <em>all</em> input characters
and stopped exactly at the beginning of the padding.</li>
<li>We have to use <code class="docutils literal"><span class="pre">re2c:define:YYFILL:naked</span> <span class="pre">=</span> <span class="pre">1;</span></code> (line 30)
in order to suppress passing a parameter to <code class="docutils literal"><span class="pre">YYFILL</span></code>.
(It was an unfortunate idea to make <code class="docutils literal"><span class="pre">YYFILL</span></code> a call expression by default:
<code class="docutils literal"><span class="pre">YYFILL</span></code> has to stop the lexer eventually. That’s why it has to be a macro and not a function.
One should either set <code class="docutils literal"><span class="pre">re2c:define:YYFILL:naked</span> <span class="pre">=</span> <span class="pre">1;</span></code> or define <code class="docutils literal"><span class="pre">YYFILL(n)</span></code> as a macro.)</li>
</ul>
<p>Compile:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ re2c -o strings.cc strings.re
$ g++ -o strings strings.cc
</pre></div>
</div>
<p>Run:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ ./strings <span class="s1">&#39;&quot;a momentary&quot;&#39;</span> <span class="s1">&#39;&quot;&quot;&#39;</span> <span class="s1">&#39;&quot;lap&quot;se&quot;&#39;</span> <span class="s1">&#39;&quot;of&#39;</span> <span class="s1">&#39;&quot;&#39;</span> <span class="s1">&#39;&quot;rea&quot;&quot;son&quot;&#39;</span> <span class="s1">&#39;&#39;</span>
str: <span class="s2">&quot;a momentary&quot;</span>
str: <span class="s2">&quot;&quot;</span>
err: <span class="s2">&quot;lap&quot;</span>se<span class="s2">&quot;</span>
<span class="s2">err: &quot;</span>of
err: <span class="s2">&quot;</span>
<span class="s2">err: &quot;</span>rea<span class="s2">&quot;&quot;</span>son<span class="s2">&quot;</span>
<span class="s2">err:</span>
</pre></div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
      Last updated on Aug 18, 2017.
    </div>
  </body>
</html>