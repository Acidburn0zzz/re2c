<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.12: http://docutils.sourceforge.net/" />
<title>Recognizing strings: the need for YYMAXFILL</title>
<link rel="stylesheet" type="text/css" href="/css/default.css" />
<link rel="alternate" type="application/atom+xml" href="/feed/atom.xml" title="Atom 1.0" />
<link rel="icon" href="/favicon.ico" />
</head>
<body>
<div class="header">
<a class="reference external" href="../index.html">[home]</a> <a class="reference external" href="examples.html">[Examples]</a>
<hr class="header"/>
</div>
<div class="document" id="recognizing-strings-the-need-for-yymaxfill">
<h1 class="title">Recognizing strings: the need for YYMAXFILL</h1>

<p>This example is about recognizing strings.
Strings (in generic sense) are different from other kinds of lexemes: they can contain <em>arbitrary</em> characters.
It makes them a way more difficult to lex: unlike <a class="reference external" href="example_01.html">Recognizing integers: the sentinel method</a> example,
we cannot use sentinel character to stop at the end of input.
Suppose, for example, that our strings may be single or double-quoted
and may contain any character in range <tt class="docutils literal">[0 - 0xFF]</tt> except quotes of the appropriate type.
This time we cannot use <tt class="docutils literal">NULL</tt> as a sentinel: input strings like <tt class="docutils literal">&quot;aha\0ha&quot;</tt> are perfectly valid,
but ill-formed strings like <tt class="docutils literal">&quot;aha\0</tt> are also possible and shouldn't crash lexer.
Any other character cannot be used for the same reason
(including quotes: each type of strings can contain quotes of the opposite type).</p>
<p>By default re2c-generated lexers use the following approach to check for the end of input:
they assume that <tt class="docutils literal">YYLIMIT</tt> is a pointer to the end of input and check by simply comparing <tt class="docutils literal">YYCURSOR</tt> and <tt class="docutils literal">YYLIMIT</tt>.
The obvious way is to check on each input character (before advancing to the next character), but it's very slow.
Instead, re2c inserts checks only at certain points in the generated program.
Each check ensures that there is enough input to proceed until the next check.
If the check fails, lexer calls <tt class="docutils literal">YYFILL(n)</tt>, which can either supply at least <tt class="docutils literal">n</tt> characters or stop:</p>
<blockquote>
<tt class="docutils literal">if ((YYLIMIT - YYCURSOR) &lt; n) YYFILL(n);</tt></blockquote>
<p>For those interested in the internal re2c algorithm used to determine checkpoints,
here is a quote from the original paper
<a class="reference external" href="../about/1994_bumbulis_cowan_re2c_a_more_versatile_scanner_generator.pdf">&quot;RE2C: a more versatile scanner generator&quot;</a>
by Peter Bumbulis, Donald D. Cowan, 1994, ACM Letters on Programming Languages and Systems (LOPLAS):</p>
<blockquote>
<em>A set of key states can be determined by discovering the strongly-connected components (SCCs) of the
DFA. An SCC is a maximal subset of states such that there exists a path from any state in the subset to any
other. The set of key states consists of all of the states in non-trivial SCCs, together with the start state.
Note that for each SCC S, we actually only have to include a subset of states of S such that when the subset
is removed, S becomes acyclic.</em></blockquote>
<p>This approach reduces the number of checks significantly, but it has a downside.
Since the lexer checks for multiple characters at once, the last few input characters may become unreachable.
Common hack is to pad input with a few fake characters that <strong>do not form a valid lexeme or lexeme suffix</strong>.
The length of padding depends on the maximal argument to <tt class="docutils literal">YYFILL</tt>
(this value is called <tt class="docutils literal">YYMAXFILL</tt> and can be generated using <tt class="docutils literal"><span class="pre">/*!max:re2c*/</span></tt> directive).</p>
<p><a class="reference external" href="02_recognizing_strings.re">[02_recognizing_strings.re]</a></p>
<pre class="code cpp literal-block">
<span class="ln"> 1 </span><span class="comment preproc">#include &lt;stdio.h&gt;
</span><span class="ln"> 2 </span><span class="comment preproc">#include &lt;string.h&gt;
</span><span class="ln"> 3 </span><span class="comment preproc"></span>
<span class="ln"> 4 </span><span class="comment multiline">/*!max:re2c*/</span>
<span class="ln"> 5 </span>
<span class="ln"> 6 </span><span class="keyword">struct</span> <span class="keyword type">input_t</span> <span class="punctuation">{</span>
<span class="ln"> 7 </span>    <span class="keyword type">size_t</span> <span class="name">len</span><span class="punctuation">;</span>
<span class="ln"> 8 </span>    <span class="keyword type">char</span> <span class="operator">*</span><span class="name">str</span><span class="punctuation">;</span>
<span class="ln"> 9 </span>
<span class="ln">10 </span>    <span class="keyword type">input_t</span><span class="punctuation">(</span><span class="keyword">const</span> <span class="keyword type">char</span> <span class="operator">*</span><span class="name">s</span><span class="punctuation">)</span>
<span class="ln">11 </span>        <span class="operator">:</span> <span class="name">len</span><span class="punctuation">(</span><span class="name">strlen</span><span class="punctuation">(</span><span class="name">s</span><span class="punctuation">))</span>
<span class="ln">12 </span>        <span class="punctuation">,</span> <span class="name">str</span><span class="punctuation">(</span><span class="keyword">new</span> <span class="keyword type">char</span><span class="punctuation">[</span><span class="name">len</span> <span class="operator">+</span> <span class="name">YYMAXFILL</span><span class="punctuation">])</span>
<span class="ln">13 </span>    <span class="punctuation">{</span>
<span class="ln">14 </span>        <span class="name">memcpy</span><span class="punctuation">(</span><span class="name">str</span><span class="punctuation">,</span> <span class="name">s</span><span class="punctuation">,</span> <span class="name">len</span><span class="punctuation">);</span>
<span class="ln">15 </span>        <span class="name">memset</span><span class="punctuation">(</span><span class="name">str</span> <span class="operator">+</span> <span class="name">len</span><span class="punctuation">,</span> <span class="literal string char">'a'</span><span class="punctuation">,</span> <span class="name">YYMAXFILL</span><span class="punctuation">);</span>
<span class="ln">16 </span>    <span class="punctuation">}</span>
<span class="ln">17 </span>    <span class="operator">~</span><span class="keyword type">input_t</span><span class="punctuation">()</span>
<span class="ln">18 </span>    <span class="punctuation">{</span>
<span class="ln">19 </span>        <span class="keyword">delete</span><span class="punctuation">[]</span><span class="name">str</span><span class="punctuation">;</span>
<span class="ln">20 </span>    <span class="punctuation">}</span>
<span class="ln">21 </span><span class="punctuation">};</span>
<span class="ln">22 </span>
<span class="ln">23 </span><span class="keyword">static</span> <span class="keyword type">bool</span> <span class="name function">lex</span><span class="punctuation">(</span><span class="keyword">const</span> <span class="keyword type">input_t</span> <span class="operator">&amp;</span> <span class="name">input</span><span class="punctuation">)</span>
<span class="ln">24 </span><span class="punctuation">{</span>
<span class="ln">25 </span>    <span class="keyword">const</span> <span class="keyword type">char</span> <span class="operator">*</span><span class="name">YYCURSOR</span> <span class="operator">=</span> <span class="name">input</span><span class="punctuation">.</span><span class="name">str</span><span class="punctuation">;</span>
<span class="ln">26 </span>    <span class="keyword">const</span> <span class="keyword type">char</span> <span class="operator">*</span><span class="keyword">const</span> <span class="name">YYLIMIT</span> <span class="operator">=</span> <span class="name">input</span><span class="punctuation">.</span><span class="name">str</span> <span class="operator">+</span> <span class="name">input</span><span class="punctuation">.</span><span class="name">len</span> <span class="operator">+</span> <span class="name">YYMAXFILL</span><span class="punctuation">;</span>
<span class="ln">27 </span>    <span class="comment multiline">/*!re2c
</span><span class="ln">28 </span><span class="comment multiline">        re2c:define:YYCTYPE = char;
</span><span class="ln">29 </span><span class="comment multiline">        re2c:define:YYFILL = &quot;return false;&quot;;
</span><span class="ln">30 </span><span class="comment multiline">        re2c:define:YYFILL:naked = 1;
</span><span class="ln">31 </span><span class="comment multiline">
</span><span class="ln">32 </span><span class="comment multiline">        sstr = &quot;'&quot;  [^']* &quot;'&quot;;
</span><span class="ln">33 </span><span class="comment multiline">        dstr = &quot;\&quot;&quot; [^&quot;]* &quot;\&quot;&quot;;
</span><span class="ln">34 </span><span class="comment multiline">
</span><span class="ln">35 </span><span class="comment multiline">        *             { return false; }
</span><span class="ln">36 </span><span class="comment multiline">        (sstr | dstr) { return YYLIMIT - YYCURSOR == YYMAXFILL; }
</span><span class="ln">37 </span><span class="comment multiline">    */</span>
<span class="ln">38 </span><span class="punctuation">}</span>
<span class="ln">39 </span>
<span class="ln">40 </span><span class="keyword type">int</span> <span class="name function">main</span><span class="punctuation">(</span><span class="keyword type">int</span> <span class="name">argc</span><span class="punctuation">,</span> <span class="keyword type">char</span> <span class="operator">**</span><span class="name">argv</span><span class="punctuation">)</span>
<span class="ln">41 </span><span class="punctuation">{</span>
<span class="ln">42 </span>    <span class="keyword">for</span> <span class="punctuation">(</span><span class="keyword type">int</span> <span class="name">i</span> <span class="operator">=</span> <span class="literal number integer">1</span><span class="punctuation">;</span> <span class="name">i</span> <span class="operator">&lt;</span> <span class="name">argc</span><span class="punctuation">;</span> <span class="operator">++</span><span class="name">i</span><span class="punctuation">)</span> <span class="punctuation">{</span>
<span class="ln">43 </span>        <span class="keyword type">input_t</span> <span class="name">arg</span><span class="punctuation">(</span><span class="name">argv</span><span class="punctuation">[</span><span class="name">i</span><span class="punctuation">]);</span>
<span class="ln">44 </span>        <span class="name">printf</span><span class="punctuation">(</span><span class="literal string">&quot;%s: %s</span><span class="literal string escape">\n</span><span class="literal string">&quot;</span><span class="punctuation">,</span> <span class="name">lex</span><span class="punctuation">(</span><span class="name">arg</span><span class="punctuation">)</span> <span class="operator">?</span> <span class="literal string">&quot;str&quot;</span> <span class="operator">:</span> <span class="literal string">&quot;err&quot;</span><span class="punctuation">,</span> <span class="name">argv</span><span class="punctuation">[</span><span class="name">i</span><span class="punctuation">]);</span>
<span class="ln">45 </span>    <span class="punctuation">}</span>
<span class="ln">46 </span>    <span class="keyword">return</span> <span class="literal number integer">0</span><span class="punctuation">;</span>
<span class="ln">47 </span><span class="punctuation">}</span>
</pre>
<p>Notes:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">/*!max:re2c*/</span></tt> (line 4) tells re2c to generate <tt class="docutils literal">#define YYMAXFILL n</tt>.</li>
<li>Input string is padded with <tt class="docutils literal">YYMAXFILL</tt> characters <tt class="docutils literal">'a'</tt> (line 15).
Sequence of <tt class="docutils literal">'a'</tt> does not form a valid lexeme or lexeme suffix
(but padding with quotes would cause false match on ill-formed input like <tt class="docutils literal">&quot;aha</tt>).</li>
<li><tt class="docutils literal">YYLIMIT</tt> points at the end of padding (line 26).</li>
<li><tt class="docutils literal">YYFILL</tt> returns an error (line 29): if the input was correct, lexer should have stopped
at the beginning of padding.</li>
<li>If the rule matched (line 36), we ensure that lexer consumed <em>all</em> input characters
and stopped exactly at the beginning of padding.</li>
<li>We have to use <tt class="docutils literal">re2c:define:YYFILL:naked = 1;</tt> (line 30)
in order to suppress passing parameter to <tt class="docutils literal">YYFILL</tt>.
(It was an unfortunate idea to make <tt class="docutils literal">YYFILL</tt> a call expression by default:
<tt class="docutils literal">YYFILL</tt> has to stop the lexer eventually, that's why it has to be a macro and not a function.
One should either set <tt class="docutils literal">re2c:define:YYFILL:naked = 1;</tt> or define <tt class="docutils literal">YYFILL(n)</tt> as a macro.)</li>
</ul>
<p>Generate, compile and run:</p>
<pre class="code bash literal-block">
<span class="name variable">$ </span>re2c -o example.cc 02_recognizing_strings.re
<span class="name variable">$ </span>g++ -o example example.cc
<span class="name variable">$ </span>./example <span class="literal string single">'&quot;a momentary&quot;'</span> <span class="literal string single">'&quot;&quot;'</span> <span class="literal string single">'&quot;lap&quot;se&quot;'</span> <span class="literal string single">'&quot;of'</span> <span class="literal string single">'&quot;'</span> <span class="literal string single">'&quot;rea&quot;&quot;son&quot;'</span> <span class="literal string single">''</span>
str: <span class="literal string double">&quot;a momentary&quot;</span>
str: <span class="literal string double">&quot;&quot;</span>
err: <span class="literal string double">&quot;lap&quot;</span>se<span class="literal string double">&quot;
err: &quot;</span>of
err: <span class="literal string double">&quot;
err: &quot;</span>rea<span class="literal string double">&quot;&quot;</span>son<span class="literal string double">&quot;
err:
</span><span class="name variable">$ </span><span class="literal string double">./example &quot;</span><span class="literal string single">'a momentary'</span><span class="literal string double">&quot; &quot;</span><span class="literal string single">''</span><span class="literal string double">&quot; &quot;</span><span class="literal string single">'lap'</span>se<span class="literal string single">'&quot; &quot;'</span>of<span class="literal string double">&quot; &quot;</span><span class="literal string single">'&quot; &quot;'</span>rea<span class="literal string single">''</span>son<span class="literal string single">'&quot; &quot;&quot;
str: '</span>a momentary<span class="literal string single">'
str: ''
err: '</span>lap<span class="literal string single">'se'</span>
err: <span class="literal string single">'of
err: '</span>
err: <span class="literal string single">'rea''son'</span>
err:
</pre>
</div>
<div class="footer">
<hr class="footer" />
<a class="reference external" href="../index.html">[home]</a> <a class="reference external" href="examples.html">[Examples]</a>
</div>
</body>
</html>
