#!/bin/bash

# somewhat portable way to detect CPU count
detect_cpu_count () {
    if [ "$CPUS" = "" ]; then
        # Windows standard environment variable
        CPUS="$NUMBER_OF_PROCESSORS"
    fi
    if [ "$CPUS" = "" ]; then
        # Linux
        CPUS=`getconf _NPROCESSORS_ONLN 2>/dev/null`
    fi
    if [ "$CPUS" = "" ]; then
        # FreeBSD
        CPUS=`getconf NPROCESSORS_ONLN 2>/dev/null`
    fi
    if [ "$CPUS" = "" ]; then
        # nothing helped
        CPUS="1"
    fi
    echo "using ${CPUS} CPUs" >&2
}

valgrind=""
threads=`detect_cpu_count; echo $CPUS`
tests=()
for arg in $*
do
	case $arg in
		"--valgrind" ) valgrind=`which valgrind` ;;
		"-j"* )
			number=${arg#-j}
			number_pattern='^[0-9]+$'
			if [[ $number =~ $number_pattern ]]
			then
				threads=$number
			fi
			;;
		* ) tests+=("$arg") ;;
	esac
done

testdir="@srcdir@/test"
if [ ${#tests[@]} -eq 0 ]
then
	tests=(`for i in $testdir; do find $i -name '*.re'; done | sort`)
fi
tests_per_thread=$((${#tests[@]} / threads + 1))
packs=()
for ((i = 0; i < threads; i++))
do
	j=$((i * tests_per_thread))
	packs[$i]=${tests[@]:j:tests_per_thread}
done

re2c='@builddir@/re2c'
if test ! -x "${re2c}"
then
	echo "Cannot find re2c executable (${re2c})."
	exit 1
fi

if test -n "${valgrind}"
then
	valgrind_options=(
		"-q"
		"--track-origins=yes"
		"--num-callers=50"
		"--leak-check=full"
		"--show-reachable=yes"
		"--malloc-fill=0xa1"
		"--free-fill=0xa1"
		)
	valgrind="${valgrind} ${valgrind_options[@]} "
	echo $valgrind
fi
re2c="${valgrind}${re2c}"

run_pack() {
	local log="$1"
	shift 1

	local errcnt=0
	for x in $*
	do
		local switches=`basename $x | sed -e 's/^[^.]*\.\(.*\)\.re$/-\1/g' -e 's/^[^-].*//g' -e 's/\([^ ]\)--/\1 --/g' -e 's/(\([^)]*\))/ \1/g' -e 's/- //g'`
		local genname=` printf "%s" "$switches" | sed -e 's,--.*$,,g' -e 's,^.[^o]*$,,g' -e 's,^[^ot]*t.*o.*$,,g' -e 's,^-[^o]*o\(.*\),'"$testdir"'/\1,g'`
		local headers=` printf "%s" "$switches" | sed -e 's,--.*$,,g' -e 's,^.[^t]*$,,g' -e 's,^[^ot]*o.*t.*$,,g' -e 's,^-[^t]*t\(.*\),'"$testdir"'/\1,g'`
		local switches=`printf "%s" "$switches" | sed -e 's,^-\([^ot-]*[ot]\)\(.*\)$,-\1'"$testdir"'/\2,g'`
		# don't use the -o flag, since it makes it harder to diff.
		local outname=$testdir/`basename ${x%.re}.c.temp`
		local outdiff=$testdir/`basename ${x%.re}.c.diff`
		local typname=$testdir/`basename ${x%.re}.h.temp`
		local typdiff=$testdir/`basename ${x%.re}.h.diff`

		$re2c $switches $x 2>&1 | LC_ALL=C sed -e "s,$x,`basename $x`,g" -e 's,/\* Generated by re2c .*\*/,/\* Generated by re2c \*/,g' > $outname
		if test -n "$genname"
		then
			cat $genname | sed -e 's,'"$testdir"'/,,g' -e 's,/\* Generated by re2c .*\*/,/\* Generated by re2c \*/,g' > $outname
			rm $genname
		fi

		if test ! -f ${x%.re}.c
		then
			echo "FAIL missing ${x%.re}.c"
			local errcnt=$(($errcnt + 1))
		else
			local r=`diff ${x%.re}.c $outname > $outdiff; echo $?`
			if [[ $r == 0 ]]
			then
				echo "OK $x: $switches"
				rm $outname
			else
				echo "FAIL $x: $switches"
				local errcnt=$(($errcnt + 1))
			fi
		fi

		if test -n "$headers"
		then
			cat $headers | sed -e 's,'"$testdir"'/,,g' -e 's,/\* Generated by re2c .*\*/,/\* Generated by re2c \*/,g' > $typname
			rm $headers
			if test ! -f ${x%.re}.h
			then
				echo "FAIL missing ${x%.re}.h"
				local errcnt=$(($errcnt + 1))
			elif diff ${x%.re}.h $typname > $typdiff
			then
				echo "OK $x: $switches"
				rm $typname
			else
				echo "FAIL $x: $switches"
				local errcnt=$(($errcnt + 1))
			fi
		fi
		test -f $outdiff -a ! -s $outdiff && rm -f $outdiff
		test -f $typdiff -a ! -s $typdiff && rm -f $typdiff
	done
	echo $errcnt > $log
}

cleanup() {
	rm -f ${logs[@]}
	kill ${wait_pids[@]}
	wait ${wait_pids[@]}
	printf "\nEh...\n"
	exit 1
}

logs=()
wait_pids=()
trap cleanup INT
for ((i = 0; i < ${#packs[@]}; i++))
do
	logs[$i]=`date +%y%m%d%H%M%S`_$i
	run_pack ${logs[i]} ${packs[i]} &
	wait_pids+=( $! )
done
wait ${wait_pids[@]}

errors=0
for ((i = 0; i < ${#logs[@]}; i++))
do
	error=`cat ${logs[i]}`
	errors=$((errors + error))
	rm -f ${logs[i]}
done


if [ $errors -eq 0 ]
then
	echo "All ${#tests[@]} tests passed successfully."
	exit 0
else
	echo "Error: $errors out ${#tests[@]} tests failed."
	exit 1
fi
