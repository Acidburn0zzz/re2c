<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.12: http://docutils.sourceforge.net/" />
<title>Arbitrary large input and YYFILL</title>
<link rel="stylesheet" type="text/css" href="/css/default.css" />
<link rel="alternate" type="application/atom+xml" href="/feed/atom.xml" title="Atom 1.0" />
<link rel="icon" href="/favicon.ico" />
</head>
<body>
<div class="header">
<a class="reference external" href="../index.html">[home]</a> <a class="reference external" href="examples.html">[Examples]</a>
<hr class="header"/>
</div>
<div class="document" id="arbitrary-large-input-and-yyfill">
<h1 class="title">Arbitrary large input and YYFILL</h1>

<p>In this example we suppose that input cannot be mapped in memory at once:
either it's too large or its size cannot be determined in advance.
The usual thing to do in such case is to allocate a buffer and lex input in chunks that fit into buffer.
re2c allows us to refill buffer using <tt class="docutils literal">YYFILL</tt>: see <a class="reference external" href="example_02.html">Recognizing strings: the need for YYMAXFILL</a> example
for details about program points and conditions that trigger <tt class="docutils literal">YYFILL</tt> invocation.
Currently re2c provides no way to combine <tt class="docutils literal">YYFILL</tt> with the sentinel method:
we have to enable <tt class="docutils literal">YYLIMIT</tt>-based checks for the end of input and pad input with <tt class="docutils literal">YYMAXFILL</tt> fake characters.
This may be changed in later versions of re2c.</p>
<p>The idea of <tt class="docutils literal">YYFILL</tt> is fairly simple: lexer is stuck upon the fact that
<tt class="docutils literal">(YYLIMIT - YYCURSOR) &lt; n</tt> and <tt class="docutils literal">YYFILL</tt> must either invert this condition or stop lexing.
Disaster will happen if <tt class="docutils literal">YYFILL</tt> fails to provide at least <tt class="docutils literal">n</tt> characters, yet resumes lexing.
Technically <tt class="docutils literal">YYFILL</tt> must somehow &quot;extend&quot; input for at least <tt class="docutils literal">n</tt> characters:
after <tt class="docutils literal">YYFILL</tt> all input pointers must point to exact same characters,
except <tt class="docutils literal">YYLIMIT</tt>: it must be advanced at least <tt class="docutils literal">n</tt> positions.
Since we want to use a fixed amount of memory, we have to shift buffer contents:
discard characters that are already lexed,
move the remaining characters at the beginning of the buffer
and fill the vacant space with new characters.
All the pointers must be decreased by the length of discarded input,
except <tt class="docutils literal">YYLIMIT</tt> (it must point at the end of buffer):</p>
<pre class="code bash literal-block">
&lt;--- discarded --&gt;                              &lt;----- n -----&gt;
oxxxxxxxxxxxxxxxxxo----------o-----------------o--------o.....o..........o... <span class="operator">(</span>more input<span class="operator">)</span>
buffer          lexeme    YYMARKER          YYCURSOR YYLIMIT *          *
<span class="punctuation">|</span>             *          *                 *            <span class="punctuation">|</span> *          *
<span class="punctuation">|</span>          *          *                 *              *<span class="punctuation">|</span>         *
<span class="punctuation">|</span>       *          *                 *              *   <span class="punctuation">|</span>      *
<span class="punctuation">|</span>    *          *                 *              *      <span class="punctuation">|</span>   *
<span class="punctuation">|</span> *          *                 *              *         <span class="punctuation">|</span>*
o-----------o-----------------o--------------o----------o
buffer,  YYMARKER          YYCURSOR                  YYLIMIT
lexeme
</pre>
<p>End of input is a special case: as explained in <a class="reference external" href="example_02.html">Recognizing strings: the need for YYMAXFILL</a> example,
the input must be padded with <tt class="docutils literal">YYMAXFILL</tt> fake characters.
In this case <tt class="docutils literal">YYLIMIT</tt> must point at the end of padding:</p>
<pre class="code bash literal-block">
&lt;--- discarded --&gt;                              &lt;----- n -----&gt;
oxxxxxxxxxxxxxxxxxo----------o-----------------o---o0000000000000000o
buffer          lexeme    YYMARKER          YYCURSOR YYLIMIT       *
<span class="punctuation">|</span>             *          *                 *   *        <span class="punctuation">|</span>       *
<span class="punctuation">|</span>          *          *                 *   *           <span class="punctuation">|</span>    *
<span class="punctuation">|</span>       *          *                 *   *              <span class="punctuation">|</span> *
<span class="punctuation">|</span>    *          *                 *   *                *<span class="punctuation">|</span>
<span class="punctuation">|</span> *          *                 *   &lt;-- YYMAXFILL --&gt;*   <span class="punctuation">|</span>
o-----------o-----------------o---o0000000000000000o    <span class="punctuation">|</span>
buffer,  YYMARKER          YYCURSOR             YYLIMIT
lexeme
</pre>
<p>Which part of input can be discarded?
The answer is, all input up to the leftmost meaningful pointer.
Intuitively it seems that it must be <tt class="docutils literal">YYMARKER</tt>: it backups input position of the latest match,
so it's always less than or equal to <tt class="docutils literal">YYCURSOR</tt>.
However, <tt class="docutils literal">YYMARKER</tt> is not always used and even when it is, its usage depends on the input:
not all control flow paths in lexer ever initialize it.
Thus for some inputs <tt class="docutils literal">YYMARKER</tt> is meaningless
and should be used with care.
In practice input rarely consists of one giant lexeme: it is usually a sequence of small lexemes.
In that case lexer runs in a loop and it is convenient to have a special &quot;lexeme start&quot; pointer.
It can be used as boundary in <tt class="docutils literal">YYFILL</tt>.</p>
<p>Our example program reads <tt class="docutils literal">stdin</tt> in chunks of 16 bytes (in real word buffer size is usually ~4Kb)
and tries to lex numbers separated by newlines.</p>
<p><a class="reference external" href="03_arbitrary_large_input.re">[03_arbitrary_large_input.re]</a></p>
<pre class="code cpp literal-block">
<span class="ln"> 1 </span><span class="comment preproc">#include &lt;stdio.h&gt;
</span><span class="ln"> 2 </span><span class="comment preproc">#include &lt;string.h&gt;
</span><span class="ln"> 3 </span><span class="comment preproc"></span>
<span class="ln"> 4 </span><span class="comment multiline">/*!max:re2c*/</span>
<span class="ln"> 5 </span><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword type">size_t</span> <span class="name">SIZE</span> <span class="operator">=</span> <span class="literal number integer">16</span><span class="punctuation">;</span>
<span class="ln"> 6 </span>
<span class="ln"> 7 </span><span class="keyword">struct</span> <span class="keyword type">input_t</span> <span class="punctuation">{</span>
<span class="ln"> 8 </span>    <span class="keyword type">char</span> <span class="name">buf</span><span class="punctuation">[</span><span class="name">SIZE</span> <span class="operator">+</span> <span class="name">YYMAXFILL</span><span class="punctuation">];</span>
<span class="ln"> 9 </span>    <span class="keyword type">char</span> <span class="operator">*</span><span class="name">lim</span><span class="punctuation">;</span>
<span class="ln">10 </span>    <span class="keyword type">char</span> <span class="operator">*</span><span class="name">cur</span><span class="punctuation">;</span>
<span class="ln">11 </span>    <span class="keyword type">char</span> <span class="operator">*</span><span class="name">tok</span><span class="punctuation">;</span>
<span class="ln">12 </span>    <span class="keyword type">bool</span> <span class="name">eof</span><span class="punctuation">;</span>
<span class="ln">13 </span>
<span class="ln">14 </span>    <span class="keyword type">input_t</span><span class="punctuation">()</span>
<span class="ln">15 </span>        <span class="operator">:</span> <span class="name">buf</span><span class="punctuation">()</span>
<span class="ln">16 </span>        <span class="punctuation">,</span> <span class="name">lim</span><span class="punctuation">(</span><span class="name">buf</span> <span class="operator">+</span> <span class="name">SIZE</span><span class="punctuation">)</span>
<span class="ln">17 </span>        <span class="punctuation">,</span> <span class="name">cur</span><span class="punctuation">(</span><span class="name">lim</span><span class="punctuation">)</span>
<span class="ln">18 </span>        <span class="punctuation">,</span> <span class="name">tok</span><span class="punctuation">(</span><span class="name">lim</span><span class="punctuation">)</span>
<span class="ln">19 </span>        <span class="punctuation">,</span> <span class="name">eof</span><span class="punctuation">(</span><span class="name builtin">false</span><span class="punctuation">)</span>
<span class="ln">20 </span>    <span class="punctuation">{}</span>
<span class="ln">21 </span>    <span class="keyword type">bool</span> <span class="name">fill</span><span class="punctuation">(</span><span class="keyword type">size_t</span> <span class="name">need</span><span class="punctuation">)</span>
<span class="ln">22 </span>    <span class="punctuation">{</span>
<span class="ln">23 </span>        <span class="keyword">if</span> <span class="punctuation">(</span><span class="name">eof</span><span class="punctuation">)</span> <span class="punctuation">{</span>
<span class="ln">24 </span>            <span class="keyword">return</span> <span class="name builtin">false</span><span class="punctuation">;</span>
<span class="ln">25 </span>        <span class="punctuation">}</span>
<span class="ln">26 </span>        <span class="keyword">const</span> <span class="keyword type">size_t</span> <span class="name">free</span> <span class="operator">=</span> <span class="name">tok</span> <span class="operator">-</span> <span class="name">buf</span><span class="punctuation">;</span>
<span class="ln">27 </span>        <span class="keyword">if</span> <span class="punctuation">(</span><span class="name">free</span> <span class="operator">&lt;</span> <span class="name">need</span><span class="punctuation">)</span> <span class="punctuation">{</span>
<span class="ln">28 </span>            <span class="keyword">return</span> <span class="name builtin">false</span><span class="punctuation">;</span>
<span class="ln">29 </span>        <span class="punctuation">}</span>
<span class="ln">30 </span>        <span class="name">memmove</span><span class="punctuation">(</span><span class="name">buf</span><span class="punctuation">,</span> <span class="name">tok</span><span class="punctuation">,</span> <span class="name">lim</span> <span class="operator">-</span> <span class="name">tok</span><span class="punctuation">);</span>
<span class="ln">31 </span>        <span class="name">lim</span> <span class="operator">-=</span> <span class="name">free</span><span class="punctuation">;</span>
<span class="ln">32 </span>        <span class="name">cur</span> <span class="operator">-=</span> <span class="name">free</span><span class="punctuation">;</span>
<span class="ln">33 </span>        <span class="name">tok</span> <span class="operator">-=</span> <span class="name">free</span><span class="punctuation">;</span>
<span class="ln">34 </span>        <span class="name">lim</span> <span class="operator">+=</span> <span class="name">fread</span><span class="punctuation">(</span><span class="name">lim</span><span class="punctuation">,</span> <span class="literal number integer">1</span><span class="punctuation">,</span> <span class="name">free</span><span class="punctuation">,</span> <span class="name">stdin</span><span class="punctuation">);</span>
<span class="ln">35 </span>        <span class="keyword">if</span> <span class="punctuation">(</span><span class="name">lim</span> <span class="operator">&lt;</span> <span class="name">buf</span> <span class="operator">+</span> <span class="name">SIZE</span><span class="punctuation">)</span> <span class="punctuation">{</span>
<span class="ln">36 </span>            <span class="name">eof</span> <span class="operator">=</span> <span class="name builtin">true</span><span class="punctuation">;</span>
<span class="ln">37 </span>            <span class="name">memset</span><span class="punctuation">(</span><span class="name">lim</span><span class="punctuation">,</span> <span class="literal number integer">0</span><span class="punctuation">,</span> <span class="name">YYMAXFILL</span><span class="punctuation">);</span>
<span class="ln">38 </span>            <span class="name">lim</span> <span class="operator">+=</span> <span class="name">YYMAXFILL</span><span class="punctuation">;</span>
<span class="ln">39 </span>        <span class="punctuation">}</span>
<span class="ln">40 </span>        <span class="keyword">return</span> <span class="name builtin">true</span><span class="punctuation">;</span>
<span class="ln">41 </span>    <span class="punctuation">}</span>
<span class="ln">42 </span><span class="punctuation">};</span>
<span class="ln">43 </span>
<span class="ln">44 </span><span class="keyword">static</span> <span class="keyword type">bool</span> <span class="name function">lex</span><span class="punctuation">(</span><span class="keyword type">input_t</span> <span class="operator">&amp;</span> <span class="name">in</span><span class="punctuation">,</span> <span class="keyword type">unsigned</span> <span class="keyword type">int</span> <span class="operator">&amp;</span><span class="name">count</span><span class="punctuation">)</span>
<span class="ln">45 </span><span class="punctuation">{</span>
<span class="ln">46 </span>    <span class="keyword">for</span> <span class="punctuation">(</span><span class="name">count</span> <span class="operator">=</span> <span class="literal number integer">0</span><span class="punctuation">;;)</span> <span class="punctuation">{</span>
<span class="ln">47 </span>        <span class="name">in</span><span class="punctuation">.</span><span class="name">tok</span> <span class="operator">=</span> <span class="name">in</span><span class="punctuation">.</span><span class="name">cur</span><span class="punctuation">;</span>
<span class="ln">48 </span>        <span class="comment multiline">/*!re2c
</span><span class="ln">49 </span><span class="comment multiline">            re2c:define:YYCTYPE = char;
</span><span class="ln">50 </span><span class="comment multiline">            re2c:define:YYCURSOR = in.cur;
</span><span class="ln">51 </span><span class="comment multiline">            re2c:define:YYLIMIT = in.lim;
</span><span class="ln">52 </span><span class="comment multiline">            re2c:define:YYFILL = &quot;if (!in.fill(&#64;&#64;)) return false;&quot;;
</span><span class="ln">53 </span><span class="comment multiline">            re2c:define:YYFILL:naked = 1;
</span><span class="ln">54 </span><span class="comment multiline">
</span><span class="ln">55 </span><span class="comment multiline">            end = &quot;\x00&quot;;
</span><span class="ln">56 </span><span class="comment multiline">            wsp = [\n]+;
</span><span class="ln">57 </span><span class="comment multiline">            num = [0-9]+;
</span><span class="ln">58 </span><span class="comment multiline">
</span><span class="ln">59 </span><span class="comment multiline">            *   { return false; }
</span><span class="ln">60 </span><span class="comment multiline">            end { return YYMAXFILL == in.lim - in.tok; }
</span><span class="ln">61 </span><span class="comment multiline">            wsp { continue; }
</span><span class="ln">62 </span><span class="comment multiline">            num { ++count; continue; }
</span><span class="ln">63 </span><span class="comment multiline">        */</span>
<span class="ln">64 </span>    <span class="punctuation">}</span>
<span class="ln">65 </span><span class="punctuation">}</span>
<span class="ln">66 </span>
<span class="ln">67 </span><span class="keyword type">int</span> <span class="name function">main</span><span class="punctuation">()</span>
<span class="ln">68 </span><span class="punctuation">{</span>
<span class="ln">69 </span>    <span class="keyword type">input_t</span> <span class="name">in</span><span class="punctuation">;</span>
<span class="ln">70 </span>    <span class="keyword type">unsigned</span> <span class="keyword type">int</span> <span class="name">count</span><span class="punctuation">;</span>
<span class="ln">71 </span>    <span class="keyword">if</span> <span class="punctuation">(</span><span class="name">lex</span><span class="punctuation">(</span><span class="name">in</span><span class="punctuation">,</span> <span class="name">count</span><span class="punctuation">))</span> <span class="punctuation">{</span>
<span class="ln">72 </span>        <span class="name">printf</span><span class="punctuation">(</span><span class="literal string">&quot;glorious %u numbers!</span><span class="literal string escape">\n</span><span class="literal string">&quot;</span><span class="punctuation">,</span> <span class="name">count</span><span class="punctuation">);</span>
<span class="ln">73 </span>    <span class="punctuation">}</span> <span class="keyword">else</span> <span class="punctuation">{</span>
<span class="ln">74 </span>        <span class="name">printf</span><span class="punctuation">(</span><span class="literal string">&quot;error</span><span class="literal string escape">\n</span><span class="literal string">&quot;</span><span class="punctuation">);</span>
<span class="ln">75 </span>    <span class="punctuation">}</span>
<span class="ln">76 </span>
<span class="ln">77 </span>    <span class="keyword">return</span> <span class="literal number integer">0</span><span class="punctuation">;</span>
<span class="ln">78 </span><span class="punctuation">}</span>
</pre>
<p>Notes:</p>
<ul class="simple">
<li><tt class="docutils literal">YYMAXFILL</tt> bytes at the end of buffer are reserved for padding.
This memory is unused most of the time, but <tt class="docutils literal">YYMAXFILL</tt> is usually negligably small compared to buffer size.</li>
<li>There is only one successsful way out (line 60): lexer must recognize a standalone
&quot;end of input&quot; lexeme (<tt class="docutils literal">NULL</tt>) exactly at the beginning of padding.
<tt class="docutils literal">YYFILL</tt> failure is an error: if the input was correct, lexer should have already stopped.</li>
<li><tt class="docutils literal">YYFILL</tt> may fail for two reasons:
either there is no more input (line 23),
or lexeme is too long: it occupies the whole buffer and nothing can be discarded (line 27).
We treat both cases in the same way (as error), but a real-world program might handle them differently
(resize buffer, cut long lexeme in two, etc.).</li>
<li><tt class="docutils literal">&#64;&#64;</tt> in <tt class="docutils literal">YYFILL</tt> definition (line 52) is a formal parameter: re2c substitutes it with the actual argument to <tt class="docutils literal">YYFILL</tt>.</li>
<li>There is a special <tt class="docutils literal">tok</tt> pointer: it points at the beginning of lexeme (line 47)
and serves as a boundary in <tt class="docutils literal">YYFILL</tt>.</li>
</ul>
<p>Generate, compile and run:</p>
<pre class="code bash literal-block">
<span class="name variable">$ </span>re2c -o example.cc 03_arbitrary_large_input.re
<span class="name variable">$ </span>g++ -o example example.cc
<span class="name variable">$ </span>./example
0
11
222
3333
44444
555555
6666666
77777777
888888888
9999999999
glorious <span class="literal number">10</span> numbers!
<span class="name variable">$ </span>seq <span class="literal number">123456789</span> <span class="punctuation">|</span> ./example
glorious <span class="literal number">123456789</span> numbers!
<span class="name variable">$ </span>seq <span class="literal number">123456789</span> <span class="punctuation">|</span> wc -l
123456789
</pre>
</div>
<div class="footer">
<hr class="footer" />
<a class="reference external" href="../index.html">[home]</a> <a class="reference external" href="examples.html">[Examples]</a>
</div>
</body>
</html>
