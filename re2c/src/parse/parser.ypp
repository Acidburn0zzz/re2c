%{

#include <assert.h>
#include <time.h>
#include <string.h>
#include <stdlib.h>
#include <iostream>
#include <set>

#include "config.h"
#include "src/codegen/skeleton/skeleton.h"
#include "src/ir/bytecode/bytecode.h"
#include "src/ir/regexp/encoding/enc.h"
#include "src/ir/regexp/encoding/range_suffix.h"
#include "src/ir/regexp/regexp_cat.h"
#include "src/ir/regexp/regexp_close.h"
#include "src/ir/regexp/regexp_null.h"
#include "src/globals.h"
#include "src/parse/code.h"
#include "src/parse/extop.h"
#include "src/parse/parser.h"
#include "src/util/c99_stdint.h"
#include "src/util/smart_ptr.h"

#define YYMALLOC malloc
#define YYFREE free

using namespace re2c;

extern "C"
{
int yylex();
void yyerror(const char*);
}

static counter_t<rule_rank_t> rank_counter;
static std::vector<std::string> condnames;
static re2c::RegExpMap  specMap;
static RegExp           *spec = NULL, *specNone = NULL;
static RuleOpList       specStar;
static Scanner          *in = NULL;
static Scanner::ParseMode  parseMode;
static SetupMap            ruleSetupMap;
static const Code * ruleDefault = NULL;
static DefaultMap          ruleDefaultMap;
static bool                foundRules;
static symbol_table_t symbol_table;

/* Bison version 1.875 emits a definition that is not working
 * with several g++ version. Hence we disable it here.
 */
#if defined(__GNUC__)
#define __attribute__(x)
#endif

void context_check(CondList *clist)
{
	if (!opts.cFlag ())
	{
		delete clist;
		in->fatal("conditions are only allowed when using -c switch");
	}
}

void context_none(CondList *clist)
{
	delete clist;
	context_check(NULL);
	in->fatal("no expression specified");
}

void context_rule
	( CondList * clist
	, const Loc & loc
	, RegExp * expr
	, RegExp * look
	, const Code * code
	, const std::string * newcond
	)
{
	context_check(clist);
	const RegExp::InsAccess ins_access = clist->size() > 1
		? RegExp::PRIVATE
		: RegExp::SHARED;
	for(CondList::const_iterator it = clist->begin(); it != clist->end(); ++it)
	{
		RuleOp * rule = new RuleOp
			( loc
			, expr
			, look
			, rank_counter.next ()
			, ins_access
			, code
			, newcond
			);

		RegExpMap::iterator itRE = specMap.find(*it);

		if (itRE != specMap.end())
		{
			itRE->second = mkAlt(itRE->second, rule);
		}
		else
		{
			specMap[*it] = rule;
			condnames.push_back (*it);
		}
		
	}
	delete clist;
	delete newcond;
}

void setup_rule(CondList *clist, const Code * code)
{
	assert(clist);
	assert(code);
	context_check(clist);
	for(CondList::const_iterator it = clist->begin(); it != clist->end(); ++it)
	{
		if (ruleSetupMap.find(*it) != ruleSetupMap.end())
		{
			in->fatalf_at(code->loc.line, "code to setup rule '%s' is already defined", it->c_str());
		}
		ruleSetupMap[*it] = std::make_pair(code->loc.line, code->text);
	}
	delete clist;
}

void default_rule(CondList *clist, const Code * code)
{
	assert(clist);
	assert(code);
	context_check(clist);
	for(CondList::const_iterator it = clist->begin(); it != clist->end(); ++it)
	{
		if (ruleDefaultMap.find(*it) != ruleDefaultMap.end())
		{
			in->fatalf_at(code->loc.line, "code to default rule '%s' is already defined", it->c_str());
		}
		ruleDefaultMap[*it] = code;
	}
	delete clist;
}

%}

%start	spec

%union {
	re2c::RegExp * regexp;
	const re2c::Code * code;
	char op;
	int32_t num;
	re2c::ExtOp extop;
	std::string * str;
	re2c::CondList * clist;
	re2c::Enc::type_t enc;
};

%token CLOSE
%token CLOSESIZE
%token CODE
%token CONF
%token CONF_CONDPREFIX
%token CONF_CONDENUMPREFIX
%token CONF_COND_DIVIDER
%token CONF_COND_DIVIDER_COND
%token CONF_COND_GOTO
%token CONF_COND_GOTO_COND
%token CONF_CGOTO_THRESHOLD
%token CONF_DEFINE_YYBACKUP
%token CONF_DEFINE_YYBACKUPCTX
%token CONF_DEFINE_YYCONDTYPE
%token CONF_DEFINE_YYCTXMARKER
%token CONF_DEFINE_YYCTYPE
%token CONF_DEFINE_YYCURSOR
%token CONF_DEFINE_YYDEBUG
%token CONF_DEFINE_YYFILL
%token CONF_DEFINE_YYFILL_NAKED
%token CONF_DEFINE_YYFILL_LEN
%token CONF_DEFINE_YYGETCONDITION
%token CONF_DEFINE_YYGETCONDITION_NAKED
%token CONF_DEFINE_YYGETSTATE
%token CONF_DEFINE_YYGETSTATE_NAKED
%token CONF_DEFINE_YYLESSTHAN
%token CONF_DEFINE_YYLIMIT
%token CONF_DEFINE_YYMARKER
%token CONF_DEFINE_YYPEEK
%token CONF_DEFINE_YYRESTORE
%token CONF_DEFINE_YYRESTORECTX
%token CONF_DEFINE_YYSETCONDITION
%token CONF_DEFINE_YYSETCONDITION_COND
%token CONF_DEFINE_YYSETSTATE
%token CONF_DEFINE_YYSETSTATE_NAKED
%token CONF_DEFINE_YYSETSTATE_STATE
%token CONF_DEFINE_YYSKIP
%token CONF_FLAGS
%token CONF_INDENT_STRING
%token CONF_INDENT_TOP
%token CONF_LABEL_YYFILLLABEL
%token CONF_LABEL_YYNEXT
%token CONF_LABELPREFIX
%token CONF_STARTLABEL
%token CONF_STATE_ABORT
%token CONF_STATE_NEXTLABEL
%token CONF_VARIABLE_YYACCEPT
%token CONF_VARIABLE_YYBM
%token CONF_VARIABLE_YYCH
%token CONF_VARIABLE_YYCTABLE
%token CONF_VARIABLE_YYSTABLE
%token CONF_VARIABLE_YYTARGET
%token CONF_YYBM_HEX
%token CONF_YYCH_CONVERSION
%token CONF_YYCH_EMIT
%token CONF_YYFILL_CHECK
%token CONF_YYFILL_ENABLE
%token CONF_YYFILL_PARAMETER
%token ID
%token FID
%token FID_END
%token NOCOND
%token NUM
%token REGEXP
%token SETUP
%token STAR
%token STRING

%type <op>      CLOSE STAR SETUP close
%type <extop>   CLOSESIZE
%type <code>    CODE
%type <regexp>  REGEXP rule look expr diff term factor primary
%type <str>     ID FID CONF STRING newcond
%type <clist>   cond clist
%type <num>     NUM
%type <enc>     CONF_FLAGS

%%

spec:
		/* empty */
		{
		}
	|	spec rule
		{
			foundRules = true;
		}
	|	spec decl
;

decl:
		ID '=' expr ';'
		{
			if (!symbol_table.insert (std::make_pair (* $1, $3)).second)
			{
				in->fatal("sym already defined");
			}
			delete $1;
			$3->ins_access = RegExp::PRIVATE;
		}
	|	FID expr FID_END
		{
			if (!symbol_table.insert (std::make_pair (* $1, $2)).second)
			{
				in->fatal("sym already defined");
			}
			delete $1;
			$2->ins_access = RegExp::PRIVATE;
		}
	|	ID '=' expr '/'
		{
			in->fatal("trailing contexts are not allowed in named definitions");
		}
	|	FID expr '/'
		{
			in->fatal("trailing contexts are not allowed in named definitions");
		}
	| CONF STRING ';'
	{
		if (!opts.sync_mapCodeName (*$1, *$2))
		{
			in->fatalf ("configuration '%s' is already set and cannot be changed", $1->c_str ());
		}
		delete $1;
		delete $2;
	}
	| CONF_CONDPREFIX STRING ';'
	{
		opts.sync_condPrefix (*$2);
		delete $2;
	}
	| CONF_CONDENUMPREFIX STRING ';'
	{
		opts.sync_condEnumPrefix (*$2);
		delete $2;
	}
	| CONF_COND_DIVIDER STRING ';'
	{
		opts.sync_condDivider (*$2);
		delete $2;
	}
	| CONF_COND_DIVIDER_COND STRING ';'
	{
		opts.sync_condDividerParam (*$2);
		delete $2;
	}
	| CONF_COND_GOTO STRING ';'
	{
		opts.sync_condGoto (*$2);
		delete $2;
	}
	| CONF_COND_GOTO_COND STRING ';'
	{
		opts.sync_condGotoParam (*$2);
		delete $2;
	}
	| CONF_CGOTO_THRESHOLD NUM ';'
	{
		if ($2 < 0)
		{
			in->fatal ("configuration 'cgoto:threshold' must be nonnegative");
		}
		opts.sync_cGotoThreshold (static_cast<uint32_t> ($2));
	}
	| CONF_DEFINE_YYFILL_NAKED NUM ';'
	{
		opts.sync_bUseYYFillNaked ($2 != 0);
	}
	| CONF_DEFINE_YYFILL_LEN STRING ';'
	{
		opts.sync_yyFillLength (*$2);
		delete $2;
	}
	| CONF_DEFINE_YYGETCONDITION_NAKED NUM ';'
	{
		opts.sync_bUseYYGetConditionNaked ($2 != 0);
	}
	| CONF_DEFINE_YYGETSTATE_NAKED NUM ';'
	{
		opts.sync_bUseYYGetStateNaked ($2 != 0);
	}
	| CONF_DEFINE_YYSETCONDITION_COND STRING ';'
	{
		opts.sync_yySetConditionParam (*$2);
		delete $2;
	}
	| CONF_DEFINE_YYSETSTATE_NAKED NUM ';'
	{
		opts.sync_bUseYYSetStateNaked ($2 != 0);
	}
	| CONF_DEFINE_YYSETSTATE_STATE STRING ';'
	{
		opts.sync_yySetStateParam (*$2);
		delete $2;
	}
	| CONF_FLAGS NUM ';'
	{
		if ($2 == 0)
		{
			opts.sync_encoding_unset ($1);
		}
		else if (!opts.sync_encoding ($1))
		{
			in->fatalf ("Cannot set %s encoding: please reset %s encoding first"
				, Enc::name ($1)
				, Enc::name (opts.encoding ().type ()));
		}
	}
	| CONF_INDENT_STRING STRING ';'
	{
		opts.sync_indString (*$2);
		delete $2;
	}
	| CONF_INDENT_TOP NUM ';'
	{
		if ($2 < 0)
		{
			in->fatal ("configuration 'indent:top' must be nonnegative");
		}
		opts.sync_topIndent (static_cast<uint32_t> ($2));
	}
	| CONF_LABELPREFIX STRING ';'
	{
		opts.sync_labelPrefix (*$2);
		delete $2;
	}
	| CONF_STARTLABEL NUM ';'
	{
		in->out.set_force_start_label ($2 != 0);
	}
	| CONF_STARTLABEL STRING ';'
	{
		in->out.set_user_start_label (*$2);
		delete $2;
	}
	| CONF_STATE_ABORT NUM ';'
	{
		opts.sync_bUseStateAbort ($2 != 0);
	}
	| CONF_STATE_NEXTLABEL NUM ';'
	{
		opts.sync_bUseStateNext ($2 != 0);
	}
	| CONF_YYBM_HEX NUM ';'
	{
		opts.sync_yybmHexTable ($2 != 0);
	}
	| CONF_YYCH_CONVERSION NUM ';'
	{
		opts.sync_yychConversion ($2 != 0);
	}
	| CONF_YYCH_EMIT NUM ';'
	{
		opts.sync_bEmitYYCh ($2 != 0);
	}
	| CONF_YYFILL_CHECK NUM ';'
	{
		opts.sync_bUseYYFillCheck ($2 != 0);
	}
	| CONF_YYFILL_ENABLE NUM ';'
	{
		opts.sync_bUseYYFill ($2 != 0);
	}
	| CONF_YYFILL_PARAMETER NUM ';'
	{
		opts.sync_bUseYYFillParam ($2 != 0);
	}
;

rule:
		expr look CODE
		{
			if (opts.cFlag ())
			{
				in->fatal("condition or '<*>' required when using -c switch");
			}
			$$ = new RuleOp
				( $3->loc
				, $1
				, $2
				, rank_counter.next ()
				, RegExp::SHARED
				, $3
				, NULL
				);
			spec = spec? mkAlt(spec, $$) : $$;
		}
	|	STAR CODE /* default rule */
		{
			if (opts.cFlag ())
				in->fatal("condition or '<*>' required when using -c switch");
			if (ruleDefault != NULL)
				in->fatal("code to default rule is already defined");
			else
				ruleDefault = $2;
		}
	|	'<' cond '>' expr look newcond CODE
		{
			context_rule ($2, $7->loc, $4, $5, $7, $6);
		}
	|	'<' cond '>' expr look ':' newcond
		{
			assert($7);
			Loc loc (in->get_fname (), in->get_cline ());
			context_rule ($2, loc, $4, $5, NULL, $7);
		}
	|	'<' cond '>' look newcond CODE
		{
			context_none($2);
			delete $5;
		}
	|	'<' cond '>' look ':' newcond
		{
			assert($6);
			context_none($2);
			delete $6;
		}
	|	'<' cond '>' STAR CODE /* default rule for conditions */
		{
			default_rule($2, $5);
		}
	|	'<' STAR '>' expr look newcond CODE
		{
			context_check(NULL);
			RuleOp * rule = new RuleOp
				( $7->loc
				, $4
				, $5
				, rank_counter.next ()
				, RegExp::PRIVATE
				, $7
				, $6
				);
			specStar.push_back (rule);
			delete $6;
		}
	|	'<' STAR '>' expr look ':' newcond
		{
			assert($7);
			context_check(NULL);
			Loc loc (in->get_fname (), in->get_cline ());
			RuleOp * rule = new RuleOp
				( loc
				, $4
				, $5
				, rank_counter.next ()
				, RegExp::PRIVATE
				, NULL
				, $7
				);
			specStar.push_back (rule);
			delete $7;
		}
	|	'<' STAR '>' look newcond CODE
		{
			context_none(NULL);
			delete $5;
		}
	|	'<' STAR '>' look ':' newcond
		{
			assert($6);
			context_none(NULL);
			delete $6;
		}
	|	'<' STAR '>' STAR CODE /* default rule for all conditions */
		{
			CondList *clist = new CondList();
			clist->insert("*");
			default_rule(clist, $5);
		}
	|	NOCOND newcond CODE
		{
			context_check(NULL);
			if (specNone)
			{
				in->fatal("code to handle illegal condition already defined");
			}
			$$ = specNone = new RuleOp
				( $3->loc
				, new NullOp
				, new NullOp
				, rank_counter.next ()
				, RegExp::SHARED
				, $3
				, $2
				);
			delete $2;
		}
	|	NOCOND ':' newcond
		{
			assert($3);
			context_check(NULL);
			if (specNone)
			{
				in->fatal("code to handle illegal condition already defined");
			}
			Loc loc (in->get_fname (), in->get_cline ());
			$$ = specNone = new RuleOp
				( loc
				, new NullOp
				, new NullOp
				, rank_counter.next ()
				, RegExp::SHARED
				, NULL
				, $3
				);
			delete $3;
		}
	|	SETUP STAR '>' CODE
		{
			CondList *clist = new CondList();
			clist->insert("*");
			setup_rule(clist, $4);
		}
	|	SETUP cond '>' CODE
		{
			setup_rule($2, $4);
		}
;

cond:
		/* empty */
		{
			in->fatal("unnamed condition not supported");
		}
	|	clist
		{
			$$ = $1;
		}
	;

clist:
		ID
		{
			$$ = new CondList();
			$$->insert(* $1);
			delete $1;
		}
	|	clist ',' ID
		{
			$1->insert(* $3);
			delete $3;
			$$ = $1;
		}
;

newcond:
		/* empty */
		{
			$$ = NULL;
		}
	|	'=' '>' ID
		{
			$$ = $3;
		}
;

look:
		/* empty */
		{
			$$ = new NullOp;
		}
	|	'/' expr
		{
			$$ = $2;
		}
;

expr:
		diff
		{
			$$ = $1;
		}
	|	expr '|' diff
		{
			$$ = mkAlt($1, $3);
		}
;

diff:
		term
		{
			$$ = $1;
		}
	|	diff '\\' term
		{
			$$ = in->mkDiff($1, $3);
		}
;

term:
		factor
		{
			$$ = $1;
		}
	|	term factor
		{
			$$ = new CatOp($1, $2);
		}
;

factor:
		primary
		{
			$$ = $1;
		}
	|	primary close
		{
			switch($2)
			{
			case '*':
				$$ = mkAlt(new CloseOp($1), new NullOp());
				break;
			case '+':
				$$ = new CloseOp($1);
				break;
			case '?':
				$$ = mkAlt($1, new NullOp());
				break;
			}
		}
	|	primary CLOSESIZE
		{
			$1->ins_access = RegExp::PRIVATE;
			if ($2.max == UINT32_MAX)
			{
				$$ = repeat_from ($1, $2.min);
			}
			else if ($2.min == $2.max)
			{
				$$ = repeat ($1, $2.min);
			}
			else
			{
				$$ = repeat_from_to ($1, $2.min, $2.max);
			}
			$$ = $$ ? $$ : new NullOp;
		}
;

close:
		CLOSE
		{
			$$ = $1;
		}
	|	STAR
		{
			$$ = $1;
		}
	|	close CLOSE
		{
			$$ = ($1 == $2) ? $1 : '*';
		}
	|	close STAR
		{
			$$ = ($1 == $2) ? $1 : '*';
		}
;

primary:
		ID
		{
			symbol_table_t::iterator i = symbol_table.find (* $1);
			delete $1;
			if (i == symbol_table.end ())
			{
				in->fatal("can't find symbol");
			}
			$$ = i->second;
		}
	|	REGEXP
		{
			$$ = $1;
		}
	|	'(' expr ')'
		{
			$$ = $2;
		}
;

%%

extern "C" {
void yyerror(const char* s)
{
	in->fatal(s);
}

int yylex(){
	return in ? in->scan() : 0;
}
} // end extern "C"

namespace re2c
{

void parse(Scanner& i, Output & o)
{
	std::map<std::string, smart_ptr<DFA> >  dfa_map;
	ScannerState rules_state;

	in = &i;

	o.source.write_version_time ();
	o.source.write_line_info (in->get_cline (), in->get_fname ().c_str ());
	if (opts.target () == opt_t::SKELETON)
	{
		Skeleton::emit_prolog (o.source);
	}

	Enc encodingOld = opts.encoding ();
	
	while ((parseMode = i.echo()) != Scanner::Stop)
	{
		o.source.new_block ();
		bool bPrologBrace = false;
		ScannerState curr_state;

		i.save_state(curr_state);
		foundRules = false;

		if (opts.rFlag () && parseMode == Scanner::Rules && dfa_map.size())
		{
			in->fatal("cannot have a second 'rules:re2c' block");
		}
		if (parseMode == Scanner::Reuse)
		{
			if (dfa_map.empty())
			{
				in->fatal("got 'use:re2c' without 'rules:re2c'");
			}
		}
		else if (parseMode == Scanner::Rules)
		{
			i.save_state(rules_state);
		}
		else
		{
			dfa_map.clear();
		}
		rank_counter.reset ();
		spec = NULL;
		ruleDefault = NULL;
		in->set_in_parse(true);
		yyparse();
		in->set_in_parse(false);
		if (opts.rFlag () && parseMode == Scanner::Reuse)
		{
			if (foundRules || opts.encoding () != encodingOld)
			{
				// Re-parse rules
				parseMode = Scanner::Parse;
				i.restore_state(rules_state);
				i.reuse();
				dfa_map.clear();
				parse_cleanup();
				spec = NULL;
				rank_counter.reset ();
				ruleDefault = NULL;
				in->set_in_parse(true);
				yyparse();
				in->set_in_parse(false);

				// Now append potential new rules
				i.restore_state(curr_state);
				parseMode = Scanner::Parse;
				in->set_in_parse(true);
				yyparse();
				in->set_in_parse(false);
			}
			encodingOld = opts.encoding ();
		}
		o.source.set_block_line (in->get_cline ());
		uint32_t ind = opts.topIndent ();
		if (opts.cFlag ())
		{
			RegExpMap::iterator it;
			SetupMap::const_iterator itRuleSetup;

			if (parseMode != Scanner::Reuse)
			{
				if (!specStar.empty())
				{
					// <*> rules must have the lowest priority
					// now that all rules have been parsed, we can fix it
					for (RuleOpList::const_iterator itOp = specStar.begin(); itOp != specStar.end(); ++itOp)
					{
						(*itOp)->rank = rank_counter.next ();
					}
					// merge <*> rules to all conditions
					// note that all conditions use the same regexp for <*> rules,
					// but compile it separately because of RegExp::PRIVATE attribute
					for (it = specMap.begin(); it != specMap.end(); ++it)
					{
						assert(it->second);
						for (RuleOpList::const_iterator itOp = specStar.begin(); itOp != specStar.end(); ++itOp)
						{
							it->second = mkAlt(*itOp, it->second);
						}
					}
				}
	
				if (specNone)
				{
					specMap["0"] = specNone;
					// Note that "0" inserts first, which is important.
					condnames.insert (condnames.begin (), "0");
				}
				o.types = condnames;
			}

			size_t nCount = specMap.size();

			for (it = specMap.begin(); it != specMap.end(); ++it)
			{
				assert(it->second);

				if (parseMode != Scanner::Reuse)
				{
					itRuleSetup = ruleSetupMap.find(it->first);				
					if (itRuleSetup != ruleSetupMap.end())
					{
						yySetupRule = itRuleSetup->second.second;
					}
					else
					{
						itRuleSetup = ruleSetupMap.find("*");
						if (itRuleSetup != ruleSetupMap.end())
						{
							yySetupRule = itRuleSetup->second.second;
						}
						else
						{
							yySetupRule = "";
						}
					}

					DefaultMap::const_iterator def = ruleDefaultMap.find (it->first);
					if (def == ruleDefaultMap.end ())
					{
						def = ruleDefaultMap.find ("*");
					}
					if (def != ruleDefaultMap.end ())
					{
						RuleOp * def_rule = new RuleOp
							( def->second->loc
							, in->mkDefault ()
							, new NullOp
							, rank_counter.next ()
							, RegExp::SHARED
							, def->second
							, NULL
							);
						it->second = it->second ? mkAlt (def_rule, it->second) : def_rule;
					}

					dfa_map[it->first] = genCode(it->second, o, it->first, opts.encoding ().nCodeUnits ());
				}
				if (parseMode != Scanner::Rules && dfa_map.find(it->first) != dfa_map.end())
				{
					dfa_map[it->first]->emit(o, ind, !--nCount, bPrologBrace);
				}
			}
		}
		else
		{
			if (ruleDefault != NULL && parseMode != Scanner::Reuse)
			{
				RuleOp * def = new RuleOp
					( ruleDefault->loc
					, in->mkDefault ()
					, new NullOp
					, rank_counter.next ()
					, RegExp::SHARED
					, ruleDefault
					, NULL
					);
				spec = spec ? mkAlt(def, spec) : def;
			}
			if (spec || !dfa_map.empty())
			{
				if (parseMode != Scanner::Reuse)
				{
					dfa_map[""] = genCode(spec, o, "", opts.encoding ().nCodeUnits ());
				}
				if (parseMode != Scanner::Rules && dfa_map.find("") != dfa_map.end())
				{
					dfa_map[""]->emit(o, ind, 0, bPrologBrace);
				}
			}
		}
		o.source.write_line_info (in->get_cline (), in->get_fname ().c_str ());
		/* restore original char handling mode*/
		opts.sync_reset_encoding (encodingOld);
	}

	if (opts.cFlag ())
	{
		SetupMap::const_iterator itRuleSetup;
		for (itRuleSetup = ruleSetupMap.begin(); itRuleSetup != ruleSetupMap.end(); ++itRuleSetup)
		{
			if (itRuleSetup->first != "*" && specMap.find(itRuleSetup->first) == specMap.end())
			{
				in->fatalf_at(itRuleSetup->second.first, "setup for non existing rule '%s' found", itRuleSetup->first.c_str());
			}
		}
		if (specMap.size() < ruleSetupMap.size())
		{
			uint32_t line = in->get_cline();
			itRuleSetup = ruleSetupMap.find("*");
			if (itRuleSetup != ruleSetupMap.end())
			{
				line = itRuleSetup->second.first;
			}
			in->fatalf_at(line, "setup for all rules with '*' not possible when all rules are setup explicitly");
		}
	}

	if (opts.target () == opt_t::SKELETON)
	{
		Skeleton::emit_epilog (o.source, o.names);
	}

	parse_cleanup();
	in = NULL;
}

void parse_cleanup()
{
	RegExp::vFreeList.clear();
	Range::vFreeList.clear();
	RangeSuffix::freeList.clear();
	Code::freelist.clear();
	symbol_table.clear ();
	condnames.clear ();
	specMap.clear();
	specStar.clear();
	specNone = NULL;
}

} // end namespace re2c
