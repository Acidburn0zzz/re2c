%{

#include "src/util/c99_stdint.h"
#include <assert.h>
#include <stddef.h>
#include <stdlib.h>
#include <limits>
#include <list>
#include <map>
#include <set>
#include <string>
#include <utility>
#include <vector>

#include "src/conf/msg.h"
#include "src/codegen/output.h"
#include "src/ir/compile.h"
#include "src/ir/adfa/adfa.h"
#include "src/ir/regexp/encoding/enc.h"
#include "src/ir/regexp/encoding/range_suffix.h"
#include "src/ir/regexp/regexp.h"
#include "src/ir/skeleton/skeleton.h"
#include "src/parse/extop.h"
#include "src/parse/parser.h"
#include "src/parse/scanner.h"
#include "src/util/free_list.h"
#include "src/util/range.h"

#define YYMALLOC malloc
#define YYFREE free

using namespace re2c;

extern "C" {

int yylex(Scanner &in, context_t&);
void yyerror(Scanner &in, context_t&, const char*);

} // extern "C"

/* Bison version 1.875 emits a definition that is not working
 * with several g++ version. Hence we disable it here.
 */
#if defined(__GNUC__)
#define __attribute__(x)
#endif

static void parse_cleanup(re2c::context_t &context)
{
	RegExp::flist.clear();
	Range::vFreeList.clear();
	RangeSuffix::freeList.clear();
	context.clear();
}

static void check_default(const Spec &spec, const std::string &cond)
{
	Spec::const_iterator
		e = spec.end(),
		i = std::find_if(spec.begin(), e, RegExpRule::is_def),
		j = std::find_if(i + 1, e, RegExpRule::is_def);
	if (j != e) {
		error("line %u: code to default rule %sis already defined at line %u",
			(*j)->code->fline, incond(cond).c_str(), (*i)->code->fline);
		exit(1);
	}
}

static void delay_default(Spec &spec)
{
	// default rule(s) should go last
	std::stable_partition(spec.begin(), spec.end(), RegExpRule::isnt_def);
}

static void check_cflag(Scanner &in)
{
	if (!in.opts->cFlag) {
		in.fatal("conditions are only allowed when using -c switch");
	}
}

static void make_rule(Scanner &in, context_t &context,
	RegExpRule *rule, Code *code)
{
	if (in.opts->cFlag) {
		in.fatal("condition or '<*>' required when using -c switch");
	}

	rule->code = code;
	context.specMap[""].push_back(rule);
}

static void make_cond(Scanner &in, context_t &context, CondList *clist,
	RegExpRule *rule, Code *code)
{
	check_cflag(in);

	rule->code = code;
	for(CondList::const_iterator i = clist->begin(); i != clist->end(); ++i) {
		const std::string &cond = *i;
		if (context.specMap.find(cond) == context.specMap.end()) {
			context.condnames.push_back(cond);
		}
		context.specMap[cond].push_back(rule);
	}
	delete clist;
}

static void make_star(Scanner &in, context_t &context, RegExpRule *rule, Code *code)
{
	check_cflag(in);

	rule->code = code;
	context.spec_all.push_back(rule);
}

static void make_zero(Scanner &in, context_t &context, Code *code)
{
	const std::string zero = "0";

	check_cflag(in);

	SpecMap::const_iterator
		i = context.specMap.find(zero),
		e = context.specMap.end();
	if (i != e) {
		error("line %u: startup code is already defined at line %u",
			code->fline, i->second[0]->code->fline);
		exit(1);
	}

	RegExpRule *rule = new RegExpRule(RegExp::make_nil(), false);
	rule->code = code;
	context.condnames.push_back(zero);
	context.specMap[zero].push_back(rule);
}

static void make_setup(Scanner &in, SetupMap &ruleSetupMap,
	CondList *clist, const Code *code)
{
	check_cflag(in);

	if (!clist) {
		clist = new CondList;
		clist->insert("*");
	}
	assert(code);
	for (CondList::const_iterator i = clist->begin(); i != clist->end(); ++i) {
		if (ruleSetupMap.find(*i) != ruleSetupMap.end()) {
			in.fatalf_at(code->fline, "code to setup rule '%s' is already defined", i->c_str());
		}
		ruleSetupMap[*i] = std::make_pair(code->fline, code->text);
	}
	delete code;
	delete clist;
}

static std::string find_setup_rule(const SetupMap &map, const std::string &key)
{
	SetupMap::const_iterator e = map.end(), i;

	i = map.find(key);
	if (i != e) return i->second.second;

	i = map.find("*");
	if (i != e) return i->second.second;

	return "";
}

%}

%start	spec

%lex-param   {Scanner &in}
%parse-param {Scanner &in}
%lex-param   {context_t &context}
%parse-param {context_t &context}

%union {
	const re2c::RegExp * regexp;
	re2c::Code * code;
	char op;
	re2c::ExtOp extop;
	std::string * str;
	re2c::CondList * clist;
	re2c::RegExpRule *rule;
};

%token TOKEN_CLOSESIZE
%token TOKEN_CODE
%token TOKEN_CONF
%token TOKEN_ID
%token TOKEN_FID
%token TOKEN_FID_END
%token TOKEN_REGEXP

%type <op>      close closes
%type <extop>   TOKEN_CLOSESIZE
%type <code>    TOKEN_CODE ccode
%type <regexp>  TOKEN_REGEXP rule expr diff term factor primary
%type <str>     TOKEN_ID TOKEN_FID name
%type <clist>   clist
%type <rule>    trailexpr

%%

spec
	: /* empty */
	| spec TOKEN_CONF
	| spec def
	| spec rule
	;

def
	: name expr enddef {
		if (!context.symbol_table.insert(std::make_pair(*$1, $2)).second) {
			in.fatal("sym already defined");
		}
		delete $1;
	}
	/* errors */
	| name expr '/' {
		in.fatal("trailing contexts are not allowed in named definitions");
	};

name
	: TOKEN_ID '=' {
		$$ = $1;
	}
	| TOKEN_FID {
		$$ = $1;
	};

enddef: ';' | TOKEN_FID_END;

rule
	: trailexpr TOKEN_CODE {
		make_rule(in, context, $1, $2);
	}

	| '<' clist '>' trailexpr ccode {
		make_cond(in, context, $2, $4, $5);
	}

	| '<' '*' '>' trailexpr ccode {
		make_star(in, context, $4, $5);
	}

	| '<' '>' ccode {
		make_zero(in, context, $3);
	}

	| '<' '!' clist '>' TOKEN_CODE {
		make_setup(in, context.ruleSetupMap, $3, $5);
	}

	| '<' '!' '*' '>' TOKEN_CODE {
		make_setup(in, context.ruleSetupMap, NULL, $5);
	};

ccode
	: TOKEN_CODE

	| '=' '>' TOKEN_ID TOKEN_CODE {
		$$ = $4;
		$$->cond = *$3;
		delete $3;
	}

	| ':' '=' '>' TOKEN_ID {
		$$ = new Code(in.get_fname(), in.get_cline());
		$$->cond = *$4;
		delete $4;
	};

clist
	: TOKEN_ID {
		$$ = new CondList;
		$$->insert(*$1);
		delete $1;
	}

	| clist ',' TOKEN_ID {
		$1->insert(*$3);
		delete $3;
		$$ = $1;
	};

trailexpr
	: expr {
		$$ = new RegExpRule($1, false);
	}

	| expr '/' expr {
		$$ = new RegExpRule(RegExp::make_cat($1,
			RegExp::make_cat(RegExp::make_tag(NULL), $3)), false);
	}

	| '*' { /* default rule */
		$$ = new RegExpRule(in.mkDefault(), true);
	};

expr:
		diff
		{
			$$ = $1;
		}
	|	expr '|' diff
		{
			$$ = mkAlt($1, $3);
		}
;

diff:
		term
		{
			$$ = $1;
		}
	|	diff '\\' term
		{
			$$ = in.mkDiff($1, $3);
		}
;

term:
		factor
		{
			$$ = $1;
		}
	|	term factor
		{
			$$ = RegExp::make_cat($1, $2);
		}
;

factor:
		primary
		{
			$$ = $1;
		}
	|	primary closes
		{
			// see note [Kleene star is expressed in terms of plus]
			switch($2)
			{
			case '*':
				$$ = RegExp::make_alt(RegExp::make_nil(),
					RegExp::make_iter($1));
				break;
			case '+':
				$$ = RegExp::make_iter($1);
				break;
			case '?':
				$$ = mkAlt($1, RegExp::make_nil());
				break;
			}
		}
	|	primary TOKEN_CLOSESIZE
		{
			if ($2.max == std::numeric_limits<uint32_t>::max())
			{
				$$ = repeat_from ($1, $2.min);
			}
			else if ($2.min == $2.max)
			{
				$$ = repeat ($1, $2.min);
			}
			else
			{
				$$ = repeat_from_to ($1, $2.min, $2.max);
			}
			$$ = $$ ? $$ : RegExp::make_nil();
		}
;

closes
	: close
	| closes close { $$ = ($1 == $2) ? $1 : '*'; }
	;

close
	: '*' { $$ = '*'; }
	| '+' { $$ = '+'; }
	| '?' { $$ = '?'; }
	;

primary:
		TOKEN_ID
		{
			symbol_table_t::iterator i = context.symbol_table.find (* $1);
			delete $1;
			if (i == context.symbol_table.end ())
			{
				in.fatal("can't find symbol");
			}
			$$ = i->second;
		}
	|	TOKEN_REGEXP
		{
			$$ = $1;
		}
	|	'(' expr ')'
		{
			$$ = $2;
		}
;

%%

extern "C" {

void yyerror(Scanner &in, context_t&, const char* s)
{
	in.fatal(s);
}

int yylex(Scanner &in, context_t&)
{
	return in.scan();
}

} // extern "C"

namespace re2c
{

void parse(Scanner &in, Output & o)
{
	dfa_map_t dfa_map;
	context_t context;
	ScannerState rules_state, curr_state;
	Opt &opts = in.opts;

	o.source.wversion_time ()
		.wline_info (in.get_cline (), in.get_fname ().c_str ());
	if (opts->target == opt_t::SKELETON)
	{
		emit_prolog (o.source);
	}

	Enc encodingOld = opts->encoding;
	for (Scanner::ParseMode mode; (mode = in.echo()) != Scanner::Stop;) {
		o.source.new_block ();
		bool bPrologBrace = false;

		in.save_state(curr_state);
		if (opts->rFlag && mode == Scanner::Rules && dfa_map.size())
		{
			in.fatal("cannot have a second 'rules:re2c' block");
		}
		if (mode == Scanner::Reuse)
		{
			if (dfa_map.empty())
			{
				in.fatal("got 'use:re2c' without 'rules:re2c'");
			}
		}
		else if (mode == Scanner::Rules)
		{
			in.save_state(rules_state);
		}
		else
		{
			dfa_map.clear();
		}
		context.specMap.clear();
		yyparse(in, context);
		if (opts->rFlag && mode == Scanner::Reuse) {
			if (!context.specMap.empty() || opts->encoding != encodingOld) {
				// Re-parse rules
				mode = Scanner::Parse;
				in.restore_state(rules_state);
				in.reuse();
				dfa_map.clear();
				parse_cleanup(context);
				context.specMap.clear();
				yyparse(in, context);

				// Now append potential new rules
				in.restore_state(curr_state);
				mode = Scanner::Parse;
				yyparse(in, context);
			}
			encodingOld = opts->encoding;
		}

		o.source.block().line = in.get_cline();
		o.source.block().types = context.condnames;

		// compile regular expressions to automata
		if (mode != Scanner::Reuse) {
			SpecMap::iterator it;
			for (it = context.specMap.begin(); it != context.specMap.end(); ++it) {
				check_default(it->second, it->first);
			}
			check_default(context.spec_all, "*");

			// merge <*> rules to all conditions except "0" with lowest priority
			for (it = context.specMap.begin(); it != context.specMap.end(); ++it) {
				if (it->first == "0") continue;
				it->second.insert(it->second.end(), context.spec_all.begin(), context.spec_all.end());
			}

			for (it = context.specMap.begin(); it != context.specMap.end(); ++it) {
				delay_default(it->second);
				const std::string &setup = find_setup_rule(context.ruleSetupMap, it->first);
				dfa_map[it->first] = compile(it->second, o, it->first, opts->encoding.nCodeUnits (), setup);
			}
		}

		// generate code
		if (mode != Scanner::Rules) {
			uint32_t ind = opts->topIndent;
			size_t nCount = dfa_map.size();
			for (dfa_map_t::const_iterator i = dfa_map.begin(); i != dfa_map.end(); ++i) {
				i->second->emit(o, ind, !--nCount, bPrologBrace);
			}
		}

		o.source.wline_info (in.get_cline (), in.get_fname ().c_str ());
		/* restore original char handling mode*/
		opts.reset_encoding (encodingOld);
	}

	SetupMap::const_iterator itRuleSetup;
	for (itRuleSetup = context.ruleSetupMap.begin(); itRuleSetup != context.ruleSetupMap.end(); ++itRuleSetup) {
		if (itRuleSetup->first != "*" && context.specMap.find(itRuleSetup->first) == context.specMap.end()) {
			in.fatalf_at(itRuleSetup->second.first, "setup for non existing rule '%s' found", itRuleSetup->first.c_str());
		}
	}
	if (context.specMap.size() < context.ruleSetupMap.size()) {
		uint32_t line = in.get_cline();
		itRuleSetup = context.ruleSetupMap.find("*");
		if (itRuleSetup != context.ruleSetupMap.end()) {
			line = itRuleSetup->second.first;
		}
		in.fatalf_at(line, "setup for all rules with '*' not possible when all rules are setup explicitly");
	}

	if (opts->target == opt_t::SKELETON)
	{
		emit_epilog (o.source, o.skeletons);
	}

	parse_cleanup(context);
}

} // end namespace re2c
