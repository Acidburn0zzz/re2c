
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Fast submatch extraction &#8212; re2c 1.0.2 documentation</title>
    <link rel="stylesheet" href="../../_static/theme-re2c.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.0.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="alternate" type="application/atom+xml" href="../../feed/atom.xml" title="Atom 1.0" />
    
 
  </head>
  <body>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="re2c-logo">
    re2c-1.0.2
</div>

<h3><a href="../../index.html">Home</a></h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../about/about.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../install/install.html">Install</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../manual/manual.html">Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../news.html">News</a></li>
</ul>

    <h3>Fast submatch extraction</h3>
    <div class="re2c-toc-local">
        <ul>
<li><a class="reference internal" href="#">Fast submatch extraction</a><ul>
<li><a class="reference internal" href="#parsing-vs-recognition">Parsing vs recognition</a></li>
<li><a class="reference internal" href="#a-simple-nfa-based-solution">A simple NFA-based solution</a></li>
<li><a class="reference internal" href="#the-difficulty-with-dfa">The difficulty with DFA</a></li>
<li><a class="reference internal" href="#dangerous-trailing-contexts">Dangerous trailing contexts</a></li>
</ul>
</li>
</ul>

    </div>

        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="fast-submatch-extraction">
<h1>Fast submatch extraction<a class="headerlink" href="#fast-submatch-extraction" title="Permalink to this headline">¶</a></h1>
<p><em>by Ulya Trofimovich</em></p>
<p>This article is an informal description
of the <a class="reference external" href="../../2017_trofimovich_tagged_deterministic_finite_automata_with_lookahead.pdf">novel algorithm</a>
used in <a class="reference external" href="../release_notes/1_0.html">re2c-1.0</a>
to implement <a class="reference external" href="../../manual/features/submatch/submatch.html">submatch extraction</a>.
It tries to explain what is it so complex about this seemingly simple problem,
why re2c has such a strange interface,
and how <em>tags</em> are related to the familiar <em>capturing groups</em> used by other regular expression engines.</p>
<div class="section" id="parsing-vs-recognition">
<h2>Parsing vs recognition<a class="headerlink" href="#parsing-vs-recognition" title="Permalink to this headline">¶</a></h2>
<p><em>Regular expressions</em> is a syntactic notation for describing <em>sets</em>.
Usually it is assumed that these sets contain strings — sequences of characters over some fixed alphabet.
This is known as the <em>language interpretation</em> of regular expressions.
For example, <img class="math" src="../../_images/math/44104ab4e692965f354dcbff7c9b8675439dd7a3.png" alt="a^*b^*"/> denotes the set of all strings that consist of a possibly empty sequence of <img class="math" src="../../_images/math/bd9d9c7512c898e0a254a0882184197bc1bd9c9f.png" alt="a"/>
followed by a possibly empty sequence of <img class="math" src="../../_images/math/57c9d14bb082716df9000146882ce365335d08f1.png" alt="b"/>:
<img class="math" src="../../_images/math/52366dae4ed5f188b990a77d00c12b3f8c608aea.png" alt="\{\epsilon, a, b, aa, ab, bb, ...\}"/>,
where <img class="math" src="../../_images/math/65d19c66c148d5016c6a89d26486bf6d1966ded1.png" alt="\epsilon"/> is a special symbol that means “empty string”.</p>
<p>Regular expressions is one possible way of describing <em>regular languages</em> —
the class of languages generated by Type 3 grammars in the Chomsky hierarchy.
For every regular expression there is an equivalent Type 3 grammar that generates the same language and vice versa.
For example, the above language can be generated by Type 3 grammar
with start symbol <img class="math" src="../../_images/math/0043fe6507e9b1d112e07a2801e24927e267dd50.png" alt="A"/> and production rules
<img class="math" src="../../_images/math/55f17bfdd5f43deacc1bf2288bf88f47ef424e1c.png" alt="\{
A \rightarrow aA | bB | a | b | \epsilon,
B \rightarrow bB | b
\}"/>.</p>
<p>It is often said that regular expressions are used for <em>matching</em> strings.
But what exactly is <em>matching</em>?
In the narrow sense of the word it means <em>recognition</em>:
one must decide if the given string belongs to the language denoted by regular expression.
For example, <img class="math" src="../../_images/math/071519578b6b666a1f45d124962eb729e037b2ec.png" alt="aaabb"/> belongs to our example language, but <img class="math" src="../../_images/math/a309a549d2c57fae7e78131732426df68635266c.png" alt="aba"/> does not.
In the broad sense of the word matching means <em>parsing</em>:
not only one must solve the membership problem,
but also find the <em>derivation</em> — the sequence of grammar rules that transform start symbol into the input string.
For example, <img class="math" src="../../_images/math/071519578b6b666a1f45d124962eb729e037b2ec.png" alt="aaabb"/> can be derived as <img class="math" src="../../_images/math/40a0350d3dc00b84f2fb40668e880b9db71fbe08.png" alt="A
\rightarrow aA
\rightarrow aaA
\rightarrow aaaA
\rightarrow aaabB
\rightarrow aaabb"/>.
Derivation gives us more information than a simple membership test,
because it reconstructs the grammatical <em>structure</em> of the input string.</p>
<p>There is no exact analogue to “derivation” in terms of regular expressions,
as their primary application is recognition, not parsing.
In lexical analysis <em>lexemes</em> usually denote primitive elements without inner structure
or with trivial structure that can be easily retrieved by the programmer.
Yet sometimes it is convenient to know which part of the input string
corresponds to a particular part of the regular expression —
the problem known as <em>submatch extraction</em>.
In our example one might want to know the substrings corresponding to <img class="math" src="../../_images/math/f8c09bb8fa9507824f5d0ffa11542c5fefa5c41b.png" alt="a^*"/> and <img class="math" src="../../_images/math/f90f3b0b1161b8b322e4540a68dac93b46a6a3e9.png" alt="b^*"/>;
this is usually denoted with the help of <em>capturing parentheses</em>: <img class="math" src="../../_images/math/2d6fa2cb783cfcc42e6debe35ced614eed85fd44.png" alt="(a^*)(b^*)"/>.
Submatch extraction is similar to partial parsing:
in order to find submatch boundaries one must find the right “path” through the regular expression.</p>
<p>In terms of NFA “derivation” means “path”.</p>
<p>how the given string can be <em>derived</em> from the language grammar.
In terms of regular expressions this means finding out
how input characters map on the different parts of the regular expression —
the problem known as <em>submatch extraction</em>.</p>
<p>For example, string <img class="math" src="../../_images/math/071519578b6b666a1f45d124962eb729e037b2ec.png" alt="aaabb"/> belongs to the above language;
it can be derived as <img class="math" src="../../_images/math/40a0350d3dc00b84f2fb40668e880b9db71fbe08.png" alt="A
\rightarrow aA
\rightarrow aaA
\rightarrow aaaA
\rightarrow aaabB
\rightarrow aaabb"/>.
In terms of regular expressions,
the <img class="math" src="../../_images/math/0bae17e456e16fff4c7d32e6dcea61f27317b0d3.png" alt="aaa"/> substring corresponds to the <img class="math" src="../../_images/math/f8c09bb8fa9507824f5d0ffa11542c5fefa5c41b.png" alt="a^*"/> subexpression; <img class="math" src="../../_images/math/4f1a75f83f6f93b35b096d43649e17155d90deef.png" alt="bb"/> corresponds to <img class="math" src="../../_images/math/f90f3b0b1161b8b322e4540a68dac93b46a6a3e9.png" alt="b^*"/>.
Each group can be further split into distinct repetitions,
and continuing in this manner we can track down the “origin” of each character.
In practice this is not necessary: one usually needs only the coarse-grained structure of the input —
a couple of high-level components marked by capturing parentheses.</p>
<p>In the narrow sense, <em>matching</em> means <em>recognition</em>:
given a regular expression and a string,
one must tell if the string belongs to the set of strings denoted by the regular expression — the <em>regular language</em>.
Recognition problem
is usually solved by converting the regular expression to a <em>nondeterministic finite automaton</em> (NFA)
and simulating the moves of the automaton on the input string.
NFA simulation takes linear time, but since the automaton is nondeterministic,
one has to track many possible paths simultaneously.
Alternatively, one can convert NFA to an equivalent <em>deterministic finite automaton</em> (DFA),
which also runs in linear time, but is much faster then NFA — there is only one possible path to track.
The conversion procedure (also known as <em>determinization</em>) is quite complex;
in some cases it may take exponential time and generate a very large DFA.
This is not a problem for compiling regular expression engines like re2c,
since they perform determinization ahead of time.</p>
<p>However, regular expression libraries perform determinization at runtime</p>
<p>Therefore all regular expression engines may be div</p>
<p>If determinization</p>
<p>In the broad sense, <em>matching</em> means <em>parsing</em>:
besides recognizing the input string
one must also tell how it can be <em>derived</em> from the regular expression.
The term “derivation” is usually</p>
</div>
<div class="section" id="a-simple-nfa-based-solution">
<h2>A simple NFA-based solution<a class="headerlink" href="#a-simple-nfa-based-solution" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="the-difficulty-with-dfa">
<h2>The difficulty with DFA<a class="headerlink" href="#the-difficulty-with-dfa" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="dangerous-trailing-contexts">
<h2>Dangerous trailing contexts<a class="headerlink" href="#dangerous-trailing-contexts" title="Permalink to this headline">¶</a></h2>
<p>The challenge of implementing submatch extraction in lexer generators like re2c is not immediately obvious.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer" role="contentinfo">
      Last updated on Sep 14, 2017.
    </div>
  </body>
</html>