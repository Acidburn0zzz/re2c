/* Generated by re2c 0.10.2.dev on Sun Apr 16 21:50:17 2006 */
#line 1 "strip_002.s.re"
/* re2c lesson_002, strip_001.s, (c) M. Boerger 2006 */
#line 14 "strip_002.s.re"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#define YYMAXFILL 4
#define	BSIZE	128

#if BSIZE < YYMAXFILL
# error BSIZE must be greater YYMAXFILL
#endif

#define	YYCTYPE		char
#define	YYCURSOR	s.cur
#define	YYLIMIT		s.lim
#define YYMARKER	s.mrk
#define YYCTXMARKER s.ctx
#define	YYFILL(n)	{ if ((res = fill(&s, n)) >= 0) break; }

typedef struct Scanner
{
	FILE		*fp;
	char		*cur, *tok, *lim, *eof, *ctx, *mrk;
	char 		buffer[BSIZE];
} Scanner;

int fill(Scanner *s, int len)
{
	if (!len)
	{
		s->tok = s->cur = s->lim = s->mrk = s->buffer;
		s->eof = 0;
	}
	if (!s->eof)
	{
		int got, cnt = s->tok - s->buffer;

		if (cnt > 0)
		{
			memcpy(s->buffer, s->tok, s->lim - s->tok);
			s->tok -= cnt;
			s->cur -= cnt;
			s->lim -= cnt;
			s->mrk -= cnt;
			s->ctx -= cnt;
		}
		cnt = BSIZE - cnt;
		if ((got = fread(s->lim, 1, cnt, s->fp)) != cnt)
		{
			s->eof = &s->lim[got];
		}
		s->lim += got;
	}
	else if (s->cur + len > s->eof)
	{
		return 0; // not enough input data
	}
	return -1;
}

void echo(Scanner *s)
{
	fwrite(s->tok, 1, s->cur - s->tok, stdout);
}

int scan(FILE *fp)
{
	int  res = 0;
	int  nlcomment = 0;
    Scanner s;

	if (!fp)
	{
		return 1; // no file was opened
	}

    s.fp = fp;
	
	fill(&s, 0);

	for(;;)
	{
		s.tok = s.cur;

#line 90 "t.c"
		{
			YYCTYPE yych;

			if((YYLIMIT - YYCURSOR) < 4) YYFILL(4);
			yych = *YYCURSOR;
			switch(yych){
			case 0x0A:	goto yy5;
			case 0x0D:	goto yy4;
			case '/':	goto yy2;
			default:	goto yy6;
			}
yy2:
			++YYCURSOR;
			switch((yych = *YYCURSOR)) {
			case '*':	goto yy12;
			case '/':	goto yy14;
			default:	goto yy3;
			}
yy3:
#line 107 "strip_002.s.re"
			{ fputc(*s.tok, stdout); continue; }
#line 112 "t.c"
yy4:
			yych = *(YYMARKER = ++YYCURSOR);
			switch(yych){
			case 0x0A:	goto yy11;
			default:	goto yy3;
			}
yy5:
			YYCTXMARKER = YYCURSOR + 1;
			yych = *(YYMARKER = ++YYCURSOR);
			switch(yych){
			case '/':	goto yy7;
			default:	goto yy3;
			}
yy6:
			yych = *++YYCURSOR;
			goto yy3;
yy7:
			yych = *++YYCURSOR;
			switch(yych){
			case '*':	goto yy9;
			default:	goto yy8;
			}
yy8:
			YYCURSOR = YYMARKER;
			goto yy3;
yy9:
			++YYCURSOR;
			YYCURSOR = YYCTXMARKER;
#line 105 "strip_002.s.re"
			{ echo(&s); nlcomment = 1; continue; }
#line 143 "t.c"
yy11:
			YYCTXMARKER = YYCURSOR + 1;
			yych = *++YYCURSOR;
			switch(yych){
			case '/':	goto yy7;
			default:	goto yy8;
			}
yy12:
			++YYCURSOR;
#line 106 "strip_002.s.re"
			{ goto comment; }
#line 155 "t.c"
yy14:
			++YYCURSOR;
#line 104 "strip_002.s.re"
			{ goto cppcomment; }
#line 160 "t.c"
		}
#line 108 "strip_002.s.re"

comment:
		s.tok = s.cur;

#line 167 "t.c"
		{
			YYCTYPE yych;
			if((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch(yych){
			case '*':	goto yy18;
			default:	goto yy20;
			}
yy18:
			++YYCURSOR;
			switch((yych = *YYCURSOR)) {
			case '/':	goto yy21;
			default:	goto yy19;
			}
yy19:
#line 113 "strip_002.s.re"
			{ goto comment; }
#line 185 "t.c"
yy20:
			yych = *++YYCURSOR;
			goto yy19;
yy21:
			++YYCURSOR;
#line 112 "strip_002.s.re"
			{ goto commentws; }
#line 193 "t.c"
		}
#line 114 "strip_002.s.re"

commentws:
		s.tok = s.cur;

#line 200 "t.c"
		{
			YYCTYPE yych;
			if((YYLIMIT - YYCURSOR) < 4) YYFILL(4);
			yych = *YYCURSOR;
			switch(yych){
			case 0x09:
			case ' ':	goto yy31;
			case 0x0A:	goto yy27;
			case 0x0D:	goto yy25;
			case '/':	goto yy29;
			default:	goto yy32;
			}
yy25:
			++YYCURSOR;
			switch((yych = *YYCURSOR)) {
			case 0x0A:	goto yy37;
			default:	goto yy26;
			}
yy26:
#line 127 "strip_002.s.re"
			{ goto commentws; }
#line 222 "t.c"
yy27:
			yych = *(YYMARKER = ++YYCURSOR);
			switch(yych){
			case '/':	goto yy35;
			default:	goto yy28;
			}
yy28:
#line 119 "strip_002.s.re"
			{
				if (!nlcomment)
				{
					echo(&s);
				}
				nlcomment = 0;
				continue;
			}
#line 239 "t.c"
yy29:
			++YYCURSOR;
			switch((yych = *YYCURSOR)) {
			case '*':	goto yy33;
			default:	goto yy30;
			}
yy30:
#line 128 "strip_002.s.re"
			{ echo(&s); nlcomment = 0; continue; }
#line 249 "t.c"
yy31:
			yych = *++YYCURSOR;
			goto yy26;
yy32:
			yych = *++YYCURSOR;
			goto yy30;
yy33:
			++YYCURSOR;
#line 118 "strip_002.s.re"
			{ nlcomment = 1; goto comment; }
#line 260 "t.c"
yy35:
			yych = *++YYCURSOR;
			switch(yych){
			case '*':	goto yy33;
			default:	goto yy36;
			}
yy36:
			YYCURSOR = YYMARKER;
			goto yy28;
yy37:
			yych = *(YYMARKER = ++YYCURSOR);
			switch(yych){
			case '/':	goto yy35;
			default:	goto yy28;
			}
		}
#line 129 "strip_002.s.re"

cppcomment:
		s.tok = s.cur;

#line 282 "t.c"
		{
			YYCTYPE yych;
			if((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch(yych){
			case 0x0A:	goto yy42;
			case 0x0D:	goto yy40;
			default:	goto yy44;
			}
yy40:
			++YYCURSOR;
			switch((yych = *YYCURSOR)) {
			case 0x0A:	goto yy45;
			default:	goto yy41;
			}
yy41:
#line 134 "strip_002.s.re"
			{ goto cppcomment; }
#line 301 "t.c"
yy42:
			++YYCURSOR;
yy43:
#line 133 "strip_002.s.re"
			{ echo(&s); continue; }
#line 307 "t.c"
yy44:
			yych = *++YYCURSOR;
			goto yy41;
yy45:
			++YYCURSOR;
			yych = *YYCURSOR;
			goto yy43;
		}
#line 135 "strip_002.s.re"

	}

	fflush(fp); // ensure we write
	if (fp != stdin)
	{
		fclose(fp); // close only if not stdin
	}
	return res; // return result
}

/**/
/**/
/***/
/***/
/****/
/****/
/*****/
/*****/
/******/
/******/

int main(int argc, char **argv)
{
	if (argc > 1)
	{
		return scan(!strcmp(argv[1], "-") ? stdin : fopen(argv[1], "r"));
	}
	else
	{
		fprintf(stderr, "%s <expr>\n", argv[0]);
		return 1;
	}
}
