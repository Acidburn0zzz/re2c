.\" Man page generated from reStructuredText.
.
.TH RE2C 1 "" "" ""
.SH NAME
re2c \- convert regular expressions to C/C++ code
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.SH SYNOPSIS
.sp
\fBre2c [OPTIONS] FILE\fP
.SH DESCRIPTION
.sp
\fBre2c\fP is a lexer generator for C/C++. It finds regular expression
specifications inside of C/C++ comments and replaces them with a
hard\-coded DFA. The user must supply some interface code in order to
control and customize the generated DFA.
.SH OPTIONS
.INDENT 0.0
.TP
.B \fB\-? \-h \-\-help\fP
Show a short help screen:
.TP
.B \fB\-b \-\-bit\-vectors\fP
Implies \fB\-s\fP\&. Use bit vectors as well to try to
coax better code out of the compiler. Most useful for
specifications with more than a few keywords (e.g., for most programming
languages).
.TP
.B \fB\-c \-\-conditions\fP
Used for (f)lex\-like condition support.
.TP
.B \fB\-d \-\-debug\-output\fP
Creates a parser that dumps information about
the current position and the state the parser is in.
This is useful for debugging parser issues and states. If you use this
switch, you need to define a \fBYYDEBUG\fP macro, which will be called like a
function with two parameters: \fBvoid YYDEBUG (int state, char current)\fP\&.
The first parameter receives the state or \fB\-1\fP and the second parameter
receives the input at the current cursor.
.TP
.B \fB\-D \-\-emit\-dot\fP
Emit Graphviz dot data, which can then be processed
with e.g., \fBdot \-Tpng input.dot > output.png\fP\&. Please note that
scanners with many states may crash dot.
.TP
.B \fB\-e \-\-ecb\fP
Generate a parser that supports EBCDIC. The generated
code can deal with any character up to 0xFF. In this mode, \fBre2c\fP assumes
an input character size of 1 byte. This switch is incompatible with
\fB\-w\fP, \fB\-x\fP, \fB\-u\fP, and \fB\-8\fP\&.
.TP
.B \fB\-f \-\-storable\-state\fP
Generate a scanner with support for storable state.
.TP
.B \fB\-F \-\-flex\-syntax\fP
Partial support for flex syntax. When this flag
is active, named definitions must be surrounded by curly braces and
can be defined without an equal sign and the terminating semicolon.
Instead, names are treated as direct double quoted strings.
.TP
.B \fB\-g \-\-computed\-gotos\fP
Generate a scanner that utilizes GCC\(aqs
computed\-goto feature. That is, \fBre2c\fP generates jump tables whenever a
decision is of certain complexity (e.g., a lot of if conditions would be
otherwise necessary). This is only usable with compilers that support this feature.
Note that this implies \fB\-b\fP and that the complexity threshold can be configured
using the \fBcgoto:threshold\fP inplace configuration.
.TP
.B \fB\-i \-\-no\-debug\-info\fP
Do not output \fB#line\fP information. This is
useful when you want use a CMS tool with \fBre2c\fP\(aqs output. You might
want to do this if you do not want to impose re2c as a build requirement
for your source.
.TP
.B \fB\-o OUTPUT \-\-output=OUTPUT\fP
Specify the \fBOUTPUT\fP file.
.TP
.B \fB\-r \-\-reusable\fP
Allows reuse of scanner definitions with \fB/*!use:re2c */\fP after \fB/*!rules:re2c */\fP\&.
In this mode, no \fB/*!re2c */\fP block and exactly one \fB/*!rules:re2c */\fP must be present.
The rules are saved and used by every \fB/*!use:re2c */\fP block that follows.
These blocks can contain inplace configurations, especially \fBre2c:flags:e\fP,
\fBre2c:flags:w\fP, \fBre2c:flags:x\fP, \fBre2c:flags:u\fP, and \fBre2c:flags:8\fP\&.
That way it is possible to create the same scanner multiple times for
different character types, different input mechanisms, or different output mechanisms.
The \fB/*!use:re2c */\fP blocks can also contain additional rules that will be appended
to the set of rules in \fB/*!rules:re2c */\fP\&.
.TP
.B \fB\-s \-\-nested\-ifs\fP
Generate nested ifs for some switches. Many
compilers need this assist to generate better code.
.TP
.B \fB\-t HEADER \-\-type\-header=HEADER\fP
Create a \fBHEADER\fP file that
contains types for the (f)lex\-like condition support. This can only be
activated when \fB\-c\fP is in use.
.TP
.B \fB\-T \-\-tags\fP
Enable submatch extraction with tags.
.TP
.B \fB\-P \-\-posix\-captures\fP
Enable submatch extraction with POSIX\-style capturing groups.
.TP
.B \fB\-u \-\-unicode\fP
Generate a parser that supports UTF\-32. The generated
code can deal with any valid Unicode character up to 0x10FFFF. In this
mode, \fBre2c\fP assumes an input character size of 4 bytes. This switch is
incompatible with \fB\-e\fP, \fB\-w\fP, \fB\-x\fP, and \fB\-8\fP\&. This implies \fB\-s\fP\&.
.TP
.B \fB\-v \-\-version\fP
Show version information.
.TP
.B \fB\-V \-\-vernum\fP
Show the version as a number in the MMmmpp (Majorm, minor, patch) format.
.TP
.B \fB\-w \-\-wide\-chars\fP
Generate a parser that supports UCS\-2. The
generated code can deal with any valid Unicode character up to 0xFFFF.
In this mode, \fBre2c\fP assumes an input character size of 2 bytes. This
switch is incompatible with \fB\-e\fP, \fB\-x\fP, \fB\-u\fP, and \fB\-8\fP\&. This implies
\fB\-s\fP\&.
.TP
.B \fB\-x \-\-utf\-16\fP
Generate a parser that supports UTF\-16. The generated
code can deal with any valid Unicode character up to 0x10FFFF. In this
mode, \fBre2c\fP assumes an input character size of 2 bytes. This switch is
incompatible with \fB\-e\fP, \fB\-w\fP, \fB\-u\fP, and \fB\-8\fP\&. This implies \fB\-s\fP\&.
.TP
.B \fB\-8 \-\-utf\-8\fP
Generate a parser that supports UTF\-8. The generated
code can deal with any valid Unicode character up to 0x10FFFF. In this
mode, \fBre2c\fP assumes an input character size of 1 byte. This switch is
incompatible with \fB\-e\fP, \fB\-w\fP, \fB\-x\fP, and \fB\-u\fP\&.
.TP
.B \fB\-\-case\-insensitive\fP
Makes all strings case insensitive. This makes
"\-quoted expressions behave as \(aq\-quoted expressions.
.TP
.B \fB\-\-case\-inverted\fP
Invert the meaning of single and double quoted
strings. With this switch, single quotes are case sensitive and double
quotes are case insensitive.
.TP
.B \fB\-\-no\-generation\-date\fP
Suppress date output in the generated file.
.TP
.B \fB\-\-no\-lookahead\fP
Use TDFA(0) instead of TDFA(1).
This option only has effect with \fB\-\-tags\fP or \fB\-\-posix\-captures\fP options.
.TP
.B \fB\-\-no\-optimize\-tags\fP
Suppress optimization of tag variables (mostly used for debugging).
.TP
.B \fB\-\-no\-version\fP
Suppress version output in the generated file.
.TP
.B \fB\-\-no\-generation\-date\fP
Suppress version output in the generated file.
.TP
.B \fB\-\-encoding\-policy POLICY\fP
Specify how \fBre2c\fP must treat Unicode
surrogates. \fBPOLICY\fP can be one of the following: \fBfail\fP (abort with
an error when a surrogate is encountered), \fBsubstitute\fP (silently replace
surrogates with the error code point 0xFFFD), \fBignore\fP (treat surrogates as
normal code points). By default, \fBre2c\fP ignores surrogates (for backward
compatibility). The Unicode standard says that standalone surrogates are
invalid code points, but different libraries and programs treat them
differently.
.TP
.B \fB\-\-input INPUT\fP
Specify re2c\(aqs input API. \fBINPUT\fP can be either \fBdefault\fP or \fBcustom\fP\&.
.TP
.B \fB\-S \-\-skeleton\fP
Instead of embedding re2c\-generated code into C/C++
source, generate a self\-contained program for the same DFA. Most useful
for correctness and performance testing.
.TP
.B \fB\-\-empty\-class POLICY\fP
What to do if the user uses an empty character
class. \fBPOLICY\fP can be one of the following: \fBmatch\-empty\fP (match empty
input: pretty illogical, but this is the default for backwards
compatibility reasons), \fBmatch\-none\fP (fail to match on any input),
\fBerror\fP (compilation error). Note that there are various ways to
construct an empty class, e.g., [], [^\ex00\-\exFF],
[\ex00\-\exFF][\ex00\-\exFF].
.TP
.B \fB\-\-dfa\-minimization <table | moore>\fP
The internal algorithm used by re2c to minimize the DFA (defaults to \fBmoore\fP).
Both the table filling algorithm and the Moore algorithm should produce the same DFA (up to states relabeling).
The table filling algorithm is much simpler and slower; it serves as a reference implementation.
.TP
.B \fB\-\-eager\-skip\fP
This option controls when the generated lexer advances to the next input symbol
(that is, increments YYCURSOR or invokes YYSKIP).
By default this happens after transition to the next state,
but \fB\-\-eager\-skip\fP option allows to override default behavior
and advance input position immediately after reading input symbol.
This option is implied by \fB\-\-no\-lookahead\fP\&.
.TP
.B \fB\-\-dump\-nfa\fP
Generate .dot representation of NFA and dump it on stderr.
.TP
.B \fB\-\-dump\-dfa\-raw\fP
Generate .dot representation of DFA under construction and dump it on stderr.
.TP
.B \fB\-\-dump\-dfa\-det\fP
Generate .dot representation of DFA immediately after determinization and dump it on stderr.
.TP
.B \fB\-\-dump\-dfa\-tagopt\fP
Generate .dot representation of DFA after tag optimizations and dump it on stderr.
.TP
.B \fB\-\-dump\-dfa\-min\fP
Generate .dot representation of DFA after minimization and dump it on stderr.
.TP
.B \fB\-\-dump\-adfa\fP
Generate .dot representation of DFA after tunneling and dump it on stderr.
.TP
.B \fB\-1 \-\-single\-pass\fP
Deprecated. Does nothing (single pass is the default now).
.UNINDENT
.INDENT 0.0
.TP
.B \fB\-W\fP
Turn on all warnings.
.TP
.B \fB\-Werror\fP
Turn warnings into errors. Note that this option alone
doesn\(aqt turn on any warnings; it only affects those warnings that have
been turned on so far or will be turned on later.
.TP
.B \fB\-W<warning>\fP
Turn on a \fBwarning\fP\&.
.TP
.B \fB\-Wno\-<warning>\fP
Turn off a \fBwarning\fP\&.
.TP
.B \fB\-Werror\-<warning>\fP
Turn on a \fBwarning\fP and treat it as an error (this implies \fB\-W<warning>\fP).
.TP
.B \fB\-Wno\-error\-<warning>\fP
Don\(aqt treat this particular \fBwarning\fP as an error. This doesn\(aqt turn off
the warning itself.
.UNINDENT
.INDENT 0.0
.TP
.B \fB\-Wcondition\-order\fP
Warn if the generated program makes implicit
assumptions about condition numbering. You should use either the \fB\-t, \-\-type\-header\fP option or
the \fB/*!types:re2c*/\fP directive to generate a mapping of condition names to numbers and then use
the autogenerated condition names.
.TP
.B \fB\-Wempty\-character\-class\fP
Warn if a regular expression contains an empty
character class. Rationally, trying to match an empty
character class makes no sense: it should always fail. However, for
backwards compatibility reasons, \fBre2c\fP allows empty character classes and
treats them as empty strings. Use the \fB\-\-empty\-class\fP option to change the default
behavior.
.TP
.B \fB\-Wmatch\-empty\-string\fP
Warn if a regular expression in a rule is
nullable (matches an empty string). If the DFA runs in a loop and an empty match
is unintentional (the input position in not advanced manually), the lexer may
get stuck in an infinite loop.
.TP
.B \fB\-Wswapped\-range\fP
Warn if the lower bound of a range is greater than its upper
bound. The default behavior is to silently swap the range bounds.
.TP
.B \fB\-Wundefined\-control\-flow\fP
Warn if some input strings cause undefined
control flow in the lexer (the faulty patterns are reported). This is the
most dangerous and most common mistake. It can be easily fixed by adding
the default rule (\fB*\fP) (this rule has the lowest priority, matches any code unit, and consumes
exactly one code unit).
.TP
.B \fB\-Wunreachable\-rules\fP
Warn about rules that are shadowed by other rules and will never match.
.TP
.B \fB\-Wuseless\-escape\fP
Warn if a symbol is escaped when it shouldn\(aqt be.
By default, re2c silently ignores such escapes, but this may as well indicate a
typo or error in the escape sequence.
.TP
.B \fB\-Wnondeterministic\-tags\fP
Warn if tag has \fBn\fP\-th degree of nondeterminism, where \fBn\fP is greater than 1.
.UNINDENT
.SH INTERFACE CODE
.sp
The user must supply interface code either in the form of C/C++ code
(macros, functions, variables, etc.) or in the form of \fBINPLACE CONFIGURATIONS\fP\&.
Which symbols must be defined and which are optional
depends on the particular use case.
.INDENT 0.0
.TP
.B \fBYYBACKUP ()\fP
Backup current input position (used only with generic API).
.TP
.B \fBYYBACKUPCTX ()\fP
Backup current input position for trailing context (used only with generic API).
.TP
.B \fBYYCONDTYPE\fP
In \fB\-c\fP mode, you can use \fB\-t\fP to generate a file that
contains the enumeration used as conditions. Each of the values refers
to a condition of a rule set.
.TP
.B \fBYYCTXMARKER\fP
l\-value of type \fBYYCTYPE *\fP\&.
The generated code saves trailing context backtracking information in
\fBYYCTXMARKER\fP\&. The user only needs to define this macro if a scanner
specification uses trailing context in one or more of its regular
expressions.
.TP
.B \fBYYCTYPE\fP
Type used to hold an input symbol (code unit). Usually
\fBchar\fP or \fBunsigned char\fP for ASCII, EBCDIC  or UTF\-8, or \fIunsigned short\fP
for UTF\-16 or UCS\-2, or \fBunsigned int\fP for UTF\-32.
.TP
.B \fBYYCURSOR\fP
l\-value of type \fBYYCTYPE *\fP that points to the current input symbol. The generated code advances
\fBYYCURSOR\fP as symbols are matched. On entry, \fBYYCURSOR\fP is assumed to
point to the first character of the current token. On exit, \fBYYCURSOR\fP
will point to the first character of the following token.
.TP
.B \fBYYDEBUG (state, current)\fP
This is only needed if the \fB\-d\fP flag was
specified. It allows easy debugging of the generated parser by calling a
user defined function for every state. The function should have the
following signature: \fBvoid YYDEBUG (int state, char current)\fP\&. The first
parameter receives the state or \-1 and the second parameter receives the
input at the current cursor.
.TP
.B \fBYYFILL (n)\fP
The generated code "calls"" \fBYYFILL (n)\fP when the
buffer needs (re)filling: at least \fBn\fP additional characters should be
provided. \fBYYFILL (n)\fP should adjust \fBYYCURSOR\fP, \fBYYLIMIT\fP, \fBYYMARKER\fP,
and \fBYYCTXMARKER\fP as needed. Note that for typical programming languages
\fBn\fP will be the length of the longest keyword plus one. The user can
place a comment of the form \fB/*!max:re2c*/\fP to insert a \fBYYMAXFILL\fP define set to the maximum
length value.
.TP
.B \fBYYGETCONDITION ()\fP
This define is used to get the condition prior to
entering the scanner code when using the \fB\-c\fP switch. The value must be
initialized with a value from the \fBYYCONDTYPE\fP enumeration type.
.TP
.B \fBYYGETSTATE ()\fP
The user only needs to define this macro if the \fB\-f\fP
flag was specified. In that case, the generated code "calls"
\fBYYGETSTATE ()\fP at the very beginning of the scanner in order to obtain
the saved state. \fBYYGETSTATE ()\fP must return a signed integer. The value
must be either \-1, indicating that the scanner is entered for the first
time, or a value previously saved by \fBYYSETSTATE (s)\fP\&. In the second
case, the scanner will resume operations right after where the last
\fBYYFILL (n)\fP was called.
.TP
.B \fBYYLESSTHAN (n)\fP
Check if less than \fBn\fP input characters are left (used only with generic API).
.TP
.B \fBYYLIMIT\fP
An expression of type \fBYYCTYPE *\fP that marks the end of the buffer \fBYYLIMIT[\-1]\fP
is the last character in the buffer). The generated code repeatedly
compares \fBYYCURSOR\fP to \fBYYLIMIT\fP to determine when the buffer needs
(re)filling.
.TP
.B \fBYYMARKER\fP
An l\-value of type \fBYYCTYPE *\fP\&.
The generated code saves backtracking information in \fBYYMARKER\fP\&. Some
simple scanners might not use this.
.TP
.B \fBYYMTAGP (t)\fP
Append current input position to the history of tag \fBt\fP\&.
.TP
.B \fBYYMTAGN (t)\fP
Append default value to the history of tag \fBt\fP\&.
.TP
.B \fBYYMAXFILL\fP
This will be automatically defined by \fB/*!max:re2c*/\fP blocks as explained above.
.TP
.B \fBYYMAXNMATCH\fP
This will be automatically defined by \fB/*!maxnmatch:re2c*/\fP\&.
.TP
.B \fBYYPEEK ()\fP
Get current input character (used only with generic API).
.TP
.B \fBYYRESTORE ()\fP
Restore input position (used only with generic API).
.TP
.B \fBYYRESTORECTX ()\fP
Restore input position from the value of trailing context (used only with generic API).
.TP
.B \fBYYRESTORETAG (t)\fP
Restore input position from the value of tag \fBt\fP (used only with generic API).
.TP
.B \fBYYSETCONDITION (c)\fP
This define is used to set the condition in
transition rules. This is only being used when \fB\-c\fP is active and
transition rules are being used.
.TP
.B \fBYYSETSTATE (s)\fP
The user only needs to define this macro if the \fB\-f\fP
flag was specified. In that case, the generated code "calls"
\fBYYSETSTATE\fP just before calling \fBYYFILL (n)\fP\&. The parameter to
\fBYYSETSTATE\fP is a signed integer that uniquely identifies the specific
instance of \fBYYFILL (n)\fP that is about to be called. Should the user
wish to save the state of the scanner and have \fBYYFILL (n)\fP return to
the caller, all he has to do is store that unique identifier in a
variable. Later, when the scanner is called again, it will call
\fBYYGETSTATE ()\fP and resume execution right where it left off. The
generated code will contain both \fBYYSETSTATE (s)\fP and \fBYYGETSTATE\fP even
if \fBYYFILL (n)\fP is disabled.
.TP
.B \fBYYSKIP ()\fP
Advance input position to the next character (used only with generic API).
.TP
.B \fBYYSTAGP (t)\fP
Save current input position to tag \fBt\fP (used only with generic API).
.TP
.B \fBYYSTAGN (t)\fP
Save default value to tag \fBt\fP (used only with generic API).
.UNINDENT
.SH SYNTAX
.sp
Code for \fBre2c\fP consists of a set of \fBRULES\fP, \fBNAMED DEFINITIONS\fP, \fBCODE\fP and
\fBINPLACE CONFIGURATIONS\fP\&.
.SS RULES
.sp
Each rule consist of a regular expression  (see \fBREGULAR EXPRESSIONS\fP) accompanied with a block of C/C++ code
which is to be executed when the associated regular expression is
matched. You can either start the code with an opening curly brace or
the sequence \fB:=\fP\&. If you use an opening curly brace, \fBre2c\fP will count brace depth
and stop looking for code automatically. Otherwise, curly braces are not
allowed and \fBre2c\fP stops looking for code at the first line that does
not begin with whitespace. If two or more rules overlap, the first rule
is preferred.
.sp
There is one special rule that can be used instead of regular expression: the default rule \fB*\fP\&.
Note that the default rule \fB*\fP differs from \fB[^]\fP: the default rule has the lowest priority,
matches any code unit (either valid or invalid) and always consumes exactly one character.
\fB[^]\fP, on the other hand, matches any valid code point (not the same as a code unit) and can consume multiple
code units. In fact, when a variable\-length encoding is used, \fB*\fP
is the only possible way to match an invalid input character.
.sp
In general, all rules have the form:
.INDENT 0.0
.INDENT 3.5
\fBregular\-expression\-or\-* code\fP
.UNINDENT
.UNINDENT
.sp
If \fB\-c\fP is active, then each regular expression is preceded by a list
of comma\-separated condition names. Besides the normal naming rules, there
are two special cases: \fB<*>\fP (these rules are merged to all conditions)
and \fB<>\fP (these rules cannot have an associated regular expression;
their code is merged to all actions). Non\-empty rules may furthermore specify the new
condition. In that case, \fBre2c\fP will generate the necessary code to
change the condition automatically. Rules can use \fB:=>\fP as a shortcut
to automatically generate code that not only sets the
new condition state but also continues execution with the new state. A
shortcut rule should not be used in a loop where there is code between
the start of the loop and the \fBre2c\fP block unless \fBre2c:cond:goto\fP
is changed to \fBcontinue\fP\&. If some code is needed before all rules (though not before simple jumps),  you
can insert it with \fB<!>\fP pseudo\-rules.
.INDENT 0.0
.INDENT 3.5
\fB<condition\-list\-or\-*> regular\-expression\-or\-* code\fP
.sp
\fB<condition\-list\-or\-*> regular\-expression\-or\-* => condition code\fP
.sp
\fB<condition\-list\-or\-*> regular\-expression\-or\-* :=> condition\fP
.sp
\fB<> code\fP
.sp
\fB<> => condition code\fP
.sp
\fB<> :=> condition\fP
.sp
\fB<!condition\-list> code\fP
.sp
\fB<!> code\fP
.UNINDENT
.UNINDENT
.SS NAMED DEFINITIONS
.sp
Named definitions are of the form:
.INDENT 0.0
.INDENT 3.5
\fBname = regular\-expression;\fP
.UNINDENT
.UNINDENT
.sp
If \fB\-F\fP is active, then named definitions are also of the form:
.INDENT 0.0
.INDENT 3.5
\fBname { regular\-expression }\fP
.UNINDENT
.UNINDENT
.SS INPLACE CONFIGURATIONS
.INDENT 0.0
.TP
.B \fBre2c:cgoto:threshold = 9;\fP
When \fB\-g\fP is active, this value specifies
the complexity threshold that triggers the generation of jump tables rather
than nested ifs and decision bitfields. The threshold is compared
against a calculated estimation of ifs needed where every used bitmap
divides the threshold by 2.
.TP
.B \fBre2c:cond:divider = \(aq/* *********************************** */\(aq;\fP
Allows to customize the divider for condition blocks. You can use \fB@@\fP
to put the name of the condition or customize the placeholder using
\fBre2c:cond:divider@cond\fP\&.
.TP
.B \fBre2c:cond:divider@cond = @@;\fP
Specifies the placeholder that will be
replaced with the condition name in \fBre2c:cond:divider\fP\&.
.TP
.B \fBre2c:condenumprefix = yyc;\fP
Allows to specify the prefix used for
condition values. That is, the text to be prepended to condition enum
values in the generated output file.
.TP
.B \fBre2c:cond:goto@cond = @@;\fP
Specifies the placeholder that will be replaced with the condition label in \fBre2c:cond:goto\fP\&.
.TP
.B \fBre2c:cond:goto = \(aqgoto @@;\(aq;\fP
Allows to customize the condition goto statements used with \fB:=>\fP style rules. You can use \fB@@\fP
to put the name of the condition or customize the placeholder using
\fBre2c:cond:goto@cond\fP\&. You can also change this to \fBcontinue;\fP, which
would allow you to continue with the next loop cycle including any code
between your loop start and your re2c block.
.TP
.B \fBre2c:condprefix = yyc;\fP
Allows to specify the prefix used for
condition labels. That is, the text to be prepended to condition labels
in the generated output file.
.TP
.B \fBre2c:define:YYBACKUPCTX = \(aqYYBACKUPCTX\(aq;\fP
Replaces \fBYYBACKUPCTX\fP identifier with the specified string.
.TP
.B \fBre2c:define:YYBACKUP = \(aqYYBACKUP\(aq;\fP
Replaces \fBYYBACKUP\fP identifier with the specified string.
.TP
.B \fBre2c:define:YYCONDTYPE = \(aqYYCONDTYPE\(aq;\fP
Enumeration used for condition support with \fB\-c\fP mode.
.TP
.B \fBre2c:define:YYCTXMARKER = \(aqYYCTXMARKER\(aq;\fP
Replaces the \fBYYCTXMARKER\fP placeholder with the specified identifier.
.TP
.B \fBre2c:define:YYCTYPE = \(aqYYCTYPE\(aq;\fP
Replaces the \fBYYCTYPE\fP placeholder with the specified type.
.TP
.B \fBre2c:define:YYCURSOR = \(aqYYCURSOR\(aq;\fP
Replaces the \fBYYCURSOR\fP placeholder with the specified identifier.
.TP
.B \fBre2c:define:YYDEBUG = \(aqYYDEBUG\(aq;\fP
Replaces the \fBYYDEBUG\fP placeholder with the specified identifier.
.TP
.B \fBre2c:define:YYFILL@len = \(aq@@\(aq;\fP
Any occurrence of this text
inside of a \fBYYFILL\fP call will be replaced with the actual argument.
.TP
.B \fBre2c:define:YYFILL:naked = 0;\fP
Controls the argument in the parentheses after \fBYYFILL\fP and
the following semicolon. If zero, both the argument and the semicolon are
omitted. If non\-zero, the argument is generated unless
\fBre2c:yyfill:parameter\fP is set to zero; the semicolon is generated
unconditionally.
.TP
.B \fBre2c:define:YYFILL = \(aqYYFILL\(aq;\fP
Define a substitution for \fBYYFILL\fP\&. Note that by default,
\fBre2c\fP generates an argument in parentheses and a semicolon after
\fBYYFILL\fP\&. If you need to make \fBYYFILL\fP an arbitrary statement rather
than a call, set \fBre2c:define:YYFILL:naked\fP to a non\-zero value and use
\fBre2c:define:YYFILL@len\fP to set a placeholder for the formal parameter inside of your \fBYYFILL\fP
body.
.TP
.B \fBre2c:define:YYGETCONDITION:naked = 0;\fP
Controls the parentheses after
\fBYYGETCONDITION\fP\&. If zero, the parentheses are omitted. If non\-zero, the parentheses are
generated.
.TP
.B \fBre2c:define:YYGETCONDITION = \(aqYYGETCONDITION\(aq;\fP
Substitution for
\fBYYGETCONDITION\fP\&. Note that by default, \fBre2c\fP generates parentheses after
\fBYYGETCONDITION\fP\&. Set \fBre2c:define:YYGETCONDITION:naked\fP to non\-zero to
omit the parentheses.
.TP
.B \fBre2c:define:YYGETSTATE:naked = 0;\fP
Controls the parentheses that follow
\fBYYGETSTATE\fP\&. If zero, the parentheses are omitted. If non\-zero, they are
generated.
.TP
.B \fBre2c:define:YYGETSTATE = \(aqYYGETSTATE\(aq;\fP
Substitution for
\fBYYGETSTATE\fP\&. Note that by default, \fBre2c\fP generates parentheses after
\fBYYGETSTATE\fP\&. Set \fBre2c:define:YYGETSTATE:naked\fP to non\-zero to omit
the parentheses.
.TP
.B \fBre2c:define:YYLESSTHAN = \(aqYYLESSTHAN\(aq;\fP
Replaces \fBYYLESSTHAN\fP identifier with the specified string.
.TP
.B \fBre2c:define:YYLIMIT = \(aqYYLIMIT\(aq;\fP
Replaces the \fBYYLIMIT\fP placeholder with the specified identifier.
needed.
.TP
.B \fBre2c:define:YYMARKER = \(aqYYMARKER\(aq;\fP
Replaces the \fBYYMARKER\fP placeholder with the specified identifier.
.TP
.B \fBre2c:define:YYMTAGN = \(aqYYMTAGN\(aq;\fP
Replaces \fBYYMTAGN\fP identifier with the specified string.
.TP
.B \fBre2c:define:YYMTAGP = \(aqYYMTAGP\(aq;\fP
Replaces \fBYYMTAGP\fP identifier with the specified string.
.TP
.B \fBre2c:define:YYPEEK = \(aqYYPEEK\(aq;\fP
Replaces \fBYYPEEK\fP identifier with the specified string.
.TP
.B \fBre2c:define:YYRESTORECTX = \(aqYYRESTORECTX\(aq;\fP
Replaces \fBYYRESTORECTX\fP identifier with the specified string.
.TP
.B \fBre2c:define:YYRESTORE = \(aqYYRESTORE\(aq;\fP
Replaces \fBYYRESTORE\fP identifier with the specified string.
.TP
.B \fBre2c:define:YYRESTORETAG = \(aqYYRESTORETAG\(aq;\fP
Replaces \fBYYRESTORETAG\fP identifier with the specified string.
.TP
.B \fBre2c:define:YYSETCONDITION@cond = \(aq@@\(aq;\fP
Any occurrence of this
text inside of \fBYYSETCONDITION\fP will be replaced with the actual
argument.
.TP
.B \fBre2c:define:YYSETCONDITION:naked = 0;\fP
Controls the argument in parentheses
and the semicolon after \fBYYSETCONDITION\fP\&. If zero, both the argument and
the semicolon are omitted. If non\-zero, both the argument and the semicolon are
generated.
.TP
.B \fBre2c:define:YYSETCONDITION = \(aqYYSETCONDITION\(aq;\fP
Substitution for
\fBYYSETCONDITION\fP\&. Note that by default, \fBre2c\fP generates an argument in
parentheses followed by semicolon after \fBYYSETCONDITION\fP\&. If you need to make
\fBYYSETCONDITION\fP an arbitrary statement rather than a call, set
\fBre2c:define:YYSETCONDITION:naked\fP to non\-zero and use
\fBre2c:define:YYSETCONDITION@cond\fP to denote the formal parameter inside of the
\fBYYSETCONDITION\fP body.
.TP
.B \fBre2c:define:YYSETSTATE:naked = 0;\fP
Controls the argument in parentheses and the
semicolon after \fBYYSETSTATE\fP\&. If zero, both argument and the semicolon are
omitted. If non\-zero, both the argument and the semicolon are generated.
.TP
.B \fBre2c:define:YYSETSTATE@state = \(aq@@\(aq;\fP
Any occurrence of this text
inside of \fBYYSETSTATE\fP will be replaced with the actual argument.
.TP
.B \fBre2c:define:YYSETSTATE = \(aqYYSETSTATE\(aq;\fP
Substitution for
\fBYYSETSTATE\fP\&. Note that by default, \fBre2c\fP generates an argument in parentheses
followed by a semicolon after \fBYYSETSTATE\fP\&. If you need to make \fBYYSETSTATE\fP an
arbitrary statement rather than a call, set
\fBre2c:define:YYSETSTATE:naked\fP to non\-zero and use
\fBre2c:define:YYSETSTATE@cond\fP to denote formal parameter inside of
your \fBYYSETSTATE\fP body.
.TP
.B \fBre2c:define:YYSKIP = \(aqYYSKIP\(aq;\fP
Replaces \fBYYSKIP\fP identifier with the specified string.
.TP
.B \fBre2c:define:YYSTAGN = \(aqYYSTAGN\(aq;\fP
Replaces \fBYYSTAGN\fP identifier with the specified string.
.TP
.B \fBre2c:define:YYSTAGP = \(aqYYSTAGP\(aq;\fP
Replaces \fBYYSTAGP\fP identifier with the specified string.
.TP
.B \fBre2c:flags:8\fP or \fBre2c:flags:utf\-8\fP
Same as \fB\-8 \-\-utf\-8\fP command\-line option.
.TP
.B \fBre2c:flags:b\fP or \fBre2c:flags:bit\-vectors\fP
Same as \fB\-b \-\-bit\-vectors\fP command\-line option.
.TP
.B \fBre2c:flags:case\-insensitive = 0;\fP
Same as \fB\-\-case\-insensitive\fP command\-line option.
.TP
.B \fBre2c:flags:case\-inverted = 0;\fP
Same as \fB\-\-case\-inverted\fP command\-line option.
.TP
.B \fBre2c:flags:d\fP or \fBre2c:flags:debug\-output\fP
Same as \fB\-d \-\-debug\-output\fP command\-line option.
.TP
.B \fBre2c:flags:dfa\-minimization = \(aqmoore\(aq;\fP
Same as \fB\-\-dfa\-minimization\fP command\-line option.
.TP
.B \fBre2c:flags:eager\-skip = 0;\fP
Same as \fB\-\-eager\-skip\fP command\-line option.
.TP
.B \fBre2c:flags:e\fP or \fBre2c:flags:ecb\fP
Same as \fB\-e \-\-ecb\fP command\-line option.
.TP
.B \fBre2c:flags:empty\-class = \(aqmatch\-empty\(aq;\fP
Same as \fB\-\-empty\-class\fP command\-line option.
.TP
.B \fBre2c:flags:encoding\-policy = \(aqignore\(aq;\fP
Same as \fB\-\-encoding\-policy\fP command\-line option.
.TP
.B \fBre2c:flags:g\fP or \fBre2c:flags:computed\-gotos\fP
Same as \fB\-g \-\-computed\-gotos\fP command\-line option.
.TP
.B \fBre2c:flags:i\fP or \fBre2c:flags:no\-debug\-info\fP
Same as \fB\-i \-\-no\-debug\-info\fP command\-line option.
.TP
.B \fBre2c:flags:input = \(aqdefault\(aq;\fP
Same as \fB\-\-input\fP command\-line option.
.TP
.B \fBre2c:flags:lookahead = 1;\fP
Same as inverted \fB\-\-no\-lookahead\fP command\-line option.
.TP
.B \fBre2c:flags:optimize\-tags = 1;\fP
Same as inverted \fB\-\-no\-optimize\-tags\fP command\-line option.
.TP
.B \fBre2c:flags:P\fP or \fBre2c:flags:posix\-captures\fP
Same as \fB\-P \-\-posix\-captures\fP command\-line option.
.TP
.B \fBre2c:flags:s\fP or \fBre2c:flags:nested\-ifs\fP
Same as \fB\-s \-\-nested\-ifs\fP command\-line option.
.TP
.B \fBre2c:flags:T\fP or \fBre2c:flags:tags\fP
Same as \fB\-T \-\-tags\fP command\-line option.
.TP
.B \fBre2c:flags:u\fP or \fBre2c:flags:unicode\fP
Same as \fB\-u \-\-unicode\fP command\-line option.
.TP
.B \fBre2c:flags:w\fP or \fBre2c:flags:wide\-chars\fP
Same as \fB\-w \-\-wide\-chars\fP command\-line option.
.TP
.B \fBre2c:flags:x\fP or \fBre2c:flags:utf\-16\fP
Same as \fB\-x \-\-utf\-16\fP command\-line option.
.TP
.B \fBre2c:indent:string = \(aq\et\(aq;\fP
Specifies the string to use for indentation. Requires a string that should
contain only whitespace unless you need something else for external tools. The easiest
way to specify spaces is to enclose them in single or double quotes.
If you do  not want any indentation at all, you can simply set this to \(aq\(aq.
.TP
.B \fBre2c:indent:top = 0;\fP
Specifies the minimum amount of indentation to
use. Requires a numeric value greater than or equal to zero.
.TP
.B \fBre2c:labelprefix = \(aqyy\(aq;\fP
Allows to change the prefix of numbered
labels. The default is \fByy\fP\&. Can be set any string that is valid in
a label name.
.TP
.B \fBre2c:label:yyFillLabel = \(aqyyFillLabel\(aq;\fP
Overrides the name of the \fByyFillLabel\fP label.
.TP
.B \fBre2c:label:yyNext = \(aqyyNext\(aq;\fP
Overrides the name of the \fByyNext\fP label.
.TP
.B \fBre2c:startlabel = 0;\fP
If set to a non zero integer, then the start
label of the next scanner block will be generated even if it isn\(aqt used by
the scanner itself. Otherwise, the normal \fByy0\fP\-like start label is only
generated if needed. If set to a text value, then a label with that
text will be generated regardless of whether the normal start label is
used or not. This setting is reset to 0 after a start label has been generated.
.TP
.B \fBre2c:state:abort = 0;\fP
When not zero and the \fB\-f\fP switch is active, then
the \fBYYGETSTATE\fP block will contain a default case that aborts and a \-1
case will be used for initialization.
.TP
.B \fBre2c:state:nextlabel = 0;\fP
Used when \fB\-f\fP is active to control
whether the \fBYYGETSTATE\fP block is followed by a \fByyNext:\fP label line.
Instead of using \fByyNext\fP, you can usually also use configuration
\fBstartlabel\fP to force a specific start label or default to \fByy0\fP as
a start label. Instead of using a dedicated label, it is often better to
separate the \fBYYGETSTATE\fP code from the actual scanner code by placing a
\fB/*!getstate:re2c*/\fP comment.
.TP
.B \fBre2c:tags:expression = \(aq@@\(aq;\fP
Allows to customize the way \fBre2c\fP addresses tag variables:
by default it emits expressions of the form \fByyt<N>\fP,
but this might be inconvenient if tag variables are defined as fields in a struct,
or for any other reason require special accessors.
For example, setting \fBre2c:tags:expression = p\->@@\fP will result in \fBp\->yyt<N>\fP\&.
.TP
.B \fBre2c:tags:prefix = \(aqyyt\(aq;\fP
Allows to override prefix of tag variables.
.TP
.B \fBre2c:variable:yyaccept = yyaccept;\fP
Overrides the name of the \fByyaccept\fP variable.
.TP
.B \fBre2c:variable:yybm = \(aqyybm\(aq;\fP
Overrides the name of the \fByybm\fP variable.
.TP
.B \fBre2c:variable:yych = \(aqyych\(aq;\fP
Overrides the name of the \fByych\fP variable.
.TP
.B \fBre2c:variable:yyctable = \(aqyyctable\(aq;\fP
When both \fB\-c\fP and \fB\-g\fP are active, \fBre2c\fP will use this variable to generate a static jump table
for \fBYYGETCONDITION\fP\&.
.TP
.B \fBre2c:variable:yystable = \(aqyystable\(aq;\fP
Deprecated.
.TP
.B \fBre2c:variable:yytarget = \(aqyytarget\(aq;\fP
Overrides the name of the \fByytarget\fP variable.
.TP
.B \fBre2c:yybm:hex = 0;\fP
If set to zero, a decimal table will be used. Otherwise, a hexadecimal table will be generated.
.TP
.B \fBre2c:yych:conversion = 0;\fP
When this setting is non zero, \fBre2c\fP automatically generates
conversion code whenever yych gets read. In this case, the type must be
defined using \fBre2c:define:YYCTYPE\fP\&.
.TP
.B \fBre2c:yych:emit = 1;\fP
Set this to zero to suppress the generation of \fIyych\fP\&.
.TP
.B \fBre2c:yyfill:check = 1;\fP
This can be set to 0 to suppress the generations of
\fBYYCURSOR\fP and \fBYYLIMIT\fP based precondition checks. This option is useful when
\fBYYLIMIT + YYMAXFILL\fP is always accessible.
.TP
.B \fBre2c:yyfill:enable = 1;\fP
Set this to zero to suppress the generation of \fBYYFILL (n)\fP\&. When using this, be sure to verify that the generated
scanner does not read beyond the available input, as allowing such behavior might
introduce severe security issues to your programs.
.TP
.B \fBre2c:yyfill:parameter = 1;\fP
Controls the argument in the parentheses that follow \fBYYFILL\fP\&. If zero, the argument is omitted.
If non\-zero, the argument is generated unless \fBre2c:define:YYFILL:naked\fP is set to non\-zero.
.UNINDENT
.SS REGULAR EXPRESSIONS
.INDENT 0.0
.TP
.B \fB"foo"\fP
literal string \fB"foo"\fP\&. ANSI\-C escape sequences can be used.
.TP
.B \fB\(aqfoo\(aq\fP
literal string \fB"foo"\fP (case insensitive for characters [a\-zA\-Z]).
ANSI\-C escape sequences can be used.
.TP
.B \fB[xyz]\fP
character class; in this case, the regular expression matches \fBx\fP, \fBy\fP, or \fBz\fP\&.
.TP
.B \fB[abj\-oZ]\fP
character class with a range in it; matches \fBa\fP, \fBb\fP, any letter from \fBj\fP through \fBo\fP, or \fBZ\fP\&.
.TP
.B \fB[^class]\fP
inverted character class.
.TP
.B \fBr \e s\fP
match any \fBr\fP which isn\(aqt \fBs\fP\&. \fBr\fP and \fBs\fP must be regular expressions
which can be expressed as character classes.
.TP
.B \fBr*\fP
zero or more occurrences of \fBr\fP\&.
.TP
.B \fBr+\fP
one or more occurrences of \fBr\fP\&.
.TP
.B \fBr?\fP
optional \fBr\fP\&.
.TP
.B \fB(r)\fP
\fBr\fP; parentheses are used to override precedence.
.TP
.B \fBr s\fP
\fBr\fP followed by \fBs\fP (concatenation).
.TP
.B \fBr | s\fP
\fBr\fP or \fBs\fP (alternative).
.TP
.B \fBr\fP / \fBs\fP
\fBr\fP but only if it is followed by \fBs\fP\&. Note that \fBs\fP is not
part of the matched text. This type of regular expression is called
"trailing context". Trailing context can only be at the end of a rule
and cannot be part of a named definition.
.TP
.B \fBr{n}\fP
matches \fBr\fP exactly \fBn\fP times.
.TP
.B \fBr{n,}\fP
matches \fBr\fP at least \fBn\fP times.
.TP
.B \fBr{n,m}\fP
matches \fBr\fP at least \fBn\fP times, but not more than \fBm\fP times.
.TP
.B \fB\&.\fP
match any character except newline.
.TP
.B \fBname\fP
matches a named definition as specified by \fBname\fP only if \fB\-F\fP is
off. If \fB\-F\fP is active then this behaves like it was enclosed in double
quotes and matches the string "name".
.TP
.B \fB@stag\fP
save input position at which \fB@stag\fP matches in a variable named \fBstag\fP
.TP
.B \fB#mtag\fP
save all input positions at which \fB#mtag\fP matches in a variable named \fBmtag\fP
(multiple positions are possible if \fB#mtag\fP is enclosed in a repetition subexpression that matches several times)
.UNINDENT
.sp
Character classes and string literals may contain octal or hexadecimal
character definitions and the following set of escape sequences:
\fB\ea\fP, \fB\eb\fP, \fB\ef\fP, \fB\en\fP, \fB\er\fP, \fB\et\fP, \fB\ev\fP, \fB\e\e\fP\&. An octal character is defined by a backslash
followed by its three octal digits (e.g., \fB\e377\fP).
Hexadecimal characters from 0 to 0xFF are defined by a backslash, a lower
case \fBx\fP and two hexadecimal digits (e.g., \fB\ex12\fP). Hexadecimal characters from 0x100 to 0xFFFF are defined by a backslash, a lower case
\fB\eu\(ga\(gaor an upper case \(ga\(ga\eX\fP, and four hexadecimal digits (e.g., \fB\eu1234\fP).
Hexadecimal characters from 0x10000 to 0xFFFFffff are defined by a backslash, an upper case \fB\eU\fP,
and eight hexadecimal digits (e.g., \fB\eU12345678\fP).
.sp
The only portable "any" rule is the default rule, \fB*\fP\&.
.SH SUBMATCH EXTRACTION
.sp
\fBre2c\fP supports two kinds of submatch extraction.
.sp
The first option is \fB\-P \-\-posix\-captures\fP: it enables POSIX\-compliant capturing groups.
In this mode parentheses in regular expressions denote the beginning and the end of capturing groups;
the whole regular expression is group number zero.
The number of groups for the matching rule is stored in a variable \fByynmatch\fP,
and submatch results are stored in \fByypmatch\fP array.
Both \fByynmatch\fP and \fByypmatch\fP should be defined by the user;
note that \fByypmatch\fP size must be at least \fB[yynmatch * 2]\fP\&.
\fBre2c\fP provides a directive \fB/*!maxnmatch:re2c*/\fP that defines a constant \fBYYMAXNMATCH\fP: the maximal value of \fByynmatch\fP among all rules.
Note that \fBre2c\fP implements POSIX\-compliant disambiguation:
each subexpression matches as long as possible,
and subexpressions that start earlier in regular expression have priority over those starting later.
.sp
Second option is \fB\-T \-\-tags\fP\&.
With this option one can use standalone tags of the form \fB@stag\fP and \fB#mtag\fP instead of capturing parentheses,
where \fBstag\fP and \fBmtag\fP are arbitrary used\-defined names.
Tags can be used anywhere inside of a regular expression; semantically they are just position markers.
Tags of the form \fB@stag\fP are called \fIs\-tags\fP: they denote a single submatch value (the last input position where this tag matched).
Tags of the form \fB#mtag\fP are called \fIm\-tags\fP: they denote multiple submatch values (the whole history of repetitions of this tag).
All tags should be defined by the user as variables with the corresponding names.
With standalone tags \fBre2c\fP uses leftmost greedy disambiguation:
submatch positions correspond to the leftmost matching path through the regular expression.
.sp
With both \fB\-\-posix\-captures\fP and \fB\-\-tags\fP options \fBre2c\fP generates a number of tag variables
that are used by the lexer to track multiple possible versions of each tag
(multiple versions are caused by possible ambiguity of submatch).
When a rule matches, ambiguity is resolved and all tags of this rule (or capturing parentheses, which are also implemented as tags)
are initialized with the values of appropriate tag variables.
Note that there is no one\-to\-one correspondence between tag variables and tags:
the same tag variable may be reused for different tags, and one tag may require multiple tag variables to hold all its ambiguous versions.
The exact number of tag variables is unknown to the user; this number is determined by \fBre2c\fP\&.
However, tag variables should be defined by the user, because it might be necessary to update them in \fBYYFILL\fP
and store them between invocations of lexer with \fB\-\-storable\-state\fP option.
Therefore \fBre2c\fP provides directives \fB/*!stags:re2c ... */\fP and \fB/*!mtags:re2c ... */\fP
that can be used to declare, initialize and manipulate tag variables.
.sp
\fIS\-tags\fP must support the following operations:
.INDENT 0.0
.IP \(bu 2
save input position to \fIs\-tag\fP:
\fBt = YYCURSOR\fP with default API, or user\-defined operation \fBYYSTAGP (t)\fP with generic API
.IP \(bu 2
save default value to \fIs\-tag\fP:
\fBt = NULL\fP with default API, or user\-defined operation \fBYYSTAGN (t)\fP with generic API
.IP \(bu 2
copy one \fIs\-tag\fP to another:
\fBt1 = t2\fP
.UNINDENT
.sp
\fIM\-tags\fP must support the following operations:
.INDENT 0.0
.IP \(bu 2
append input position to \fIm\-tag\fP:
user\-defined operation \fBYYMTAGP (t)\fP with both default and generic API
.IP \(bu 2
append default value to \fIm\-tag\fP:
user\-defined operation \fBYYMTAGN (t)\fP with both default and generic API
.IP \(bu 2
copy one \fIm\-tag\fP to another:
\fBt1 = t2\fP
.UNINDENT
.sp
\fIS\-tags\fP can be implemented as scalar values (pointers or offsets).
\fIM\-tags\fP need a more complex representation, as they need to store a sequence of tag values.
The most naive and inefficient representation of \fIm\-tag\fP is a list (array, vector) of tag values;
a more efficient representation is to store all \fIm\-tags\fP in a prefix\-tree
represented as array of nodes \fB(v, p)\fP, where \fBv\fP is tag value and \fBp\fP is a pointer to parent node.
.sp
For further details see \fBhttp://re2c.org/examples/examples.html\fP page on the website
or \fBre2c/examples/\fP subdirectory of \fBre2c\fP distribution.
.SH SCANNER WITH STORABLE STATES
.sp
When the \fB\-f\fP flag is specified, \fBre2c\fP generates a scanner that can
store its current state, return to its caller, and later resume
operations exactly where it left off.
.sp
The default mode of operation in \fBre2c\fP is a
"pull" model, where the scanner asks for extra input whenever it needs it. However, this mode of operation assumes that the scanner is the "owner" of the parsing loop, and that may not always be convenient.
.sp
Typically, if there is a preprocessor ahead of the scanner in the
stream, or for that matter, any other procedural source of data, the
scanner cannot "ask" for more data unless both the scanner and the source
live in separate threads.
.sp
The \fB\-f\fP flag is useful exactly for situations like that: it lets users design
scanners that work in a "push" model, i.e., a model where data is fed to the
scanner chunk by chunk. When the scanner runs out of data to consume, it
stores its state and returns to the caller. When more input data is
fed to the scanner, it resumes operations exactly where it left off.
.sp
Changes needed compared to the "pull" model:
.INDENT 0.0
.IP \(bu 2
The user has to supply macros named \fBYYSETSTATE ()\fP and \fBYYGETSTATE (state)\fP\&.
.IP \(bu 2
The \fB\-f\fP option inhibits declaration of \fByych\fP and \fByyaccept\fP, so the
user has to declare them and save and restore them where required.
In the \fBexamples/push_model/push.re\fP example, these are declared as
fields of a (C++) class of which the scanner is a method, so they do
not need to be saved/restored explicitly. For C, they could, e.g., be made
macros that select fields from a structure passed in as a parameter.
Alternatively, they could be declared as local variables, saved with
\fBYYFILL (n)\fP when it decides to return and restored upon entering the
function. Also, it could be more efficient to save the state from
\fBYYFILL (n)\fP because \fBYYSETSTATE (state)\fP is called unconditionally.
\fBYYFILL (n)\fP however does not get \fBstate\fP as a parameter, so we would have
to store state in a local variable by \fBYYSETSTATE (state)\fP\&.
.IP \(bu 2
Modify \fBYYFILL (n)\fP to return (from the function calling it) if more input is needed.
.IP \(bu 2
Modify the caller to recognize if more input is needed and respond appropriately.
.IP \(bu 2
The generated code will contain a switch block that is used to
restore the last state by jumping behind the corresponding \fBYYFILL (n)\fP
call. This code is automatically generated in the epilogue of the first \fB/*!re2c */\fP
block. It is possible to trigger generation of the \fBYYGETSTATE ()\fP
block earlier by placing a \fB/*!getstate:re2c*/\fP comment. This is especially useful when the scanner code should be
wrapped inside a loop.
.UNINDENT
.sp
Please see \fBexamples/push_model/push.re\fP for an example of a "push" model scanner. The
generated code can be tweaked with inplace configurations \fBstate:abort\fP
and \fBstate:nextlabel\fP\&.
.SH SCANNER WITH CONDITION SUPPORT
.sp
You can precede regular expressions with a list of condition names when
using the \fB\-c\fP switch. \fBre2c\fP will then generate a scanner block for
each condition, and each of the generated blocks will have its own
precondition. The precondition is given by the interface define
\fBYYGETCONDITON()\fP and must be of type \fBYYCONDTYPE\fP\&.
.sp
There are two special rule types. First, the rules of the condition \fB<*>\fP
are merged to all conditions (note that they have a lower priority than
other rules of that condition). And second, the empty condition list
allows to provide a code block that does not have a scanner part,
meaning it does not allow any regular expressions. The condition value
referring to this special block is always the one with the enumeration
value 0. This way the code of this special rule can be used to
initialize a scanner. It is in no way necessary to have these rules: but
sometimes it is helpful to have a dedicated uninitialized condition
state.
.sp
Non empty rules allow to specify the new condition, which makes them
transition rules. Besides generating calls for the
\fBYYSETCONDTITION\fP define, no other special code is generated.
.sp
There is another kind of special rule that allows to prepend code to any
code block of all rules of a certain set of conditions or to all code
blocks of all rules. This can be helpful when some operation is common
among rules. For instance, this can be used to store the length of the
scanned string. These special setup rules start with an exclamation mark
followed by either a list of conditions \fB<! condition, ... >\fP or a star
\fB<!*>\fP\&. When \fBre2c\fP generates the code for a rule whose state does not have a
setup rule and a starred setup rule is present, the starred setup code will be
used as setup code.
.SH ENCODINGS
.sp
\fBre2c\fP supports the following encodings: ASCII (default), EBCDIC (\fB\-e\fP),
UCS\-2 (\fB\-w\fP), UTF\-16 (\fB\-x\fP), UTF\-32 (\fB\-u\fP) and UTF\-8 (\fB\-8\fP).
See also inplace configuration \fBre2c:flags\fP\&.
.sp
The following concepts should be clarified when talking about encodings.
A \fIcode point\fP is an abstract number that represents a single symbol.
A \fIcode unit\fP is the smallest unit of memory, which is used in the
encoded text (it corresponds to one character in the input stream). One
or more code units may be needed to represent a single code point,
depending on the encoding. In a \fIfixed\-length\fP encoding, each code point
is represented with an equal number of code units. In \fIvariable\-length\fP
encodings, different code points can be represented with different number
of code units.
.INDENT 0.0
.IP \(bu 2
ASCII is a fixed\-length encoding. Its code space includes 0x100
code points, from 0 to 0xFF. A code point is represented with exactly one
1\-byte code unit, which has the same value as the code point. The size of
\fBYYCTYPE\fP must be 1 byte.
.IP \(bu 2
EBCDIC is a fixed\-length encoding. Its code space includes 0x100
code points, from 0 to 0xFF. A code point is represented with exactly
one 1\-byte code unit, which has the same value as the code point. The size
of \fBYYCTYPE\fP must be 1 byte.
.IP \(bu 2
UCS\-2 is a fixed\-length encoding. Its code space includes 0x10000
code points, from 0 to 0xFFFF. One code point is represented with
exactly one 2\-byte code unit, which has the same value as the code
point. The size of \fBYYCTYPE\fP must be 2 bytes.
.IP \(bu 2
UTF\-16 is a variable\-length encoding. Its code space includes all
Unicode code points, from 0 to 0xD7FF and from 0xE000 to 0x10FFFF. One
code point is represented with one or two 2\-byte code units. The size of
\fBYYCTYPE\fP must be 2 bytes.
.IP \(bu 2
UTF\-32 is a fixed\-length encoding. Its code space includes all
Unicode code points, from 0 to 0xD7FF and from 0xE000 to 0x10FFFF. One
code point is represented with exactly one 4\-byte code unit. The size of
\fBYYCTYPE\fP must be 4 bytes.
.IP \(bu 2
UTF\-8 is a variable\-length encoding. Its code space includes all
Unicode code points, from 0 to 0xD7FF and from 0xE000 to 0x10FFFF. One
code point is represented with a sequence of one, two, three, or four
1\-byte code units. The size of \fBYYCTYPE\fP must be 1 byte.
.UNINDENT
.sp
In Unicode, values from range 0xD800 to 0xDFFF (surrogates) are not
valid Unicode code points. Any encoded sequence of code units that
would map to Unicode code points in the range 0xD800\-0xDFFF, is
ill\-formed. The user can control how \fBre2c\fP treats such ill\-formed
sequences with the \fB\-\-encoding\-policy <policy>\fP switch.
.sp
For some encodings, there are code units that never occur in a valid
encoded stream (e.g., 0xFF byte in UTF\-8). If the generated scanner must
check for invalid input, the only correct way to do so is to use the default
rule (\fB*\fP). Note that the full range rule (\fB[^]\fP) won\(aqt catch invalid code units when a variable\-length encoding is used
(\fB[^]\fP means "any valid code point", whereas the default rule (\fB*\fP) means "any possible code unit").
.SH GENERIC INPUT API
.sp
\fBre2c\fP usually operates on input with pointer\-like primitives
\fBYYCURSOR\fP, \fBYYMARKER\fP, \fBYYCTXMARKER\fP, and \fBYYLIMIT\fP\&.
.sp
The generic input API (enabled with the \fB\-\-input custom\fP switch) allows
customizing input operations. In this mode, \fBre2c\fP will express all
operations on input in terms of the following primitives:
.INDENT 0.0
.INDENT 3.5
.TS
center;
|l|l|.
_
T{
\fBYYPEEK ()\fP
T}	T{
get current input character
T}
_
T{
\fBYYSKIP ()\fP
T}	T{
advance to next character
T}
_
T{
\fBYYBACKUP ()\fP
T}	T{
backup current input position
T}
_
T{
\fBYYBACKUPCTX ()\fP
T}	T{
backup current input position for trailing context
T}
_
T{
\fBYYSTAGP (t)\fP
T}	T{
save current input position to tag \fBt\fP
T}
_
T{
\fBYYSTAGN (t)\fP
T}	T{
save default value to tag \fBt\fP
T}
_
T{
\fBYYMTAGP (t)\fP
T}	T{
append input position to the history of tag \fBt\fP
T}
_
T{
\fBYYMTAGN (t)\fP
T}	T{
append default value to the history of tag \fBt\fP
T}
_
T{
\fBYYRESTORE ()\fP
T}	T{
restore current input position
T}
_
T{
\fBYYRESTORECTX ()\fP
T}	T{
restore current input position for trailing context
T}
_
T{
\fBYYRESTORETAG (t)\fP
T}	T{
restore current input position from tag \fBt\fP
T}
_
T{
\fBYYLESSTHAN (n)\fP
T}	T{
check if less than \fBn\fP input characters are left
T}
_
.TE
.UNINDENT
.UNINDENT
.sp
A couple of useful links that provide some examples:
.INDENT 0.0
.IP 1. 3
\fI\%http://skvadrik.github.io/aleph_null/posts/re2c/2015\-01\-13\-input_model.html\fP
.IP 2. 3
\fI\%http://skvadrik.github.io/aleph_null/posts/re2c/2015\-01\-15\-input_model_custom.html\fP
.UNINDENT
.SH SEE ALSO
.sp
You can find more information about \fBre2c\fP at: \fI\%http://re2c.org\fP\&.
See also: flex(1), lex(1), quex (\fI\%http://quex.sourceforge.net\fP).
.SH AUTHORS
.sp
Peter Bumbulis   \fI\%peter@csg.uwaterloo.ca\fP
.sp
Brian Young      \fI\%bayoung@acm.org\fP
.sp
Dan Nuffer       \fI\%nuffer@users.sourceforge.net\fP
.sp
Marcus Boerger   \fI\%helly@users.sourceforge.net\fP
.sp
Hartmut Kaiser   \fI\%hkaiser@users.sourceforge.net\fP
.sp
Emmanuel Mogenet \fI\%mgix@mgix.com\fP
.sp
Ulya Trofimovich \fI\%skvadrik@gmail.com\fP
.SH VERSION INFORMATION
.sp
This manpage describes \fBre2c\fP version 1.0, package date 11 Aug 2017.
.\" Generated by docutils manpage writer.
.
